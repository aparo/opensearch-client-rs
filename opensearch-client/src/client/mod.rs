use std::collections::HashMap;
/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */

use futures::stream::{self, StreamExt};
use std::error;
use std::fmt;
use tokio::task::JoinHandle;
pub mod auth_middleware;
pub mod credentials;
use crate::bulk::*;
use crate::bulker::Bulker;
use crate::bulker::BulkerBuilder;
use crate::common;
use crate::common::*;
use bon::bon;
use futures::Stream;
use opensearch_dsl::Query;
use opensearch_dsl::SortCollection;
use serde::de::DeserializeOwned;
use serde::Serialize;
use thiserror::Error;
use url::Url;

pub trait Request {
    type Response: DeserializeOwned + Send + Sync;
    fn method(&self) -> reqwest::Method;
    fn path(&self) -> Result<String, Error>;
    fn body(&self) -> Result<Option<String>, Error>;
    fn query_args(&self) -> Result<Option<HashMap<String, String>>, Error>;
    fn url(&self, base_url: &Url) -> Result<Url, Error> {
        let mut url = base_url.clone();
        url.set_path(&self.path()?);
        if let Some(query_args) = self.query_args()? {
            url.query_pairs_mut()
                .clear()
                .extend_pairs(query_args.iter());
        }
        Ok(url)
    }
}

#[derive(Debug, Clone)]
pub struct ResponseContent {
    pub status: reqwest::StatusCode,
    pub content: String,
}

impl fmt::Display for ResponseContent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ResponseContent {{ status: {}, content: {} }}",
            self.status, self.content
        )
    }
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("Document Already Exists: ({0},{1})")]
    DocumentAlreadyExistsError(String, String),
    #[error("Not found: ({0},{1})")]
    DocumentNotFoundError(String, String),
    /// An expected response code whose deserialization failed.
    #[error(transparent)]
    InvalidResponsePayload(#[from] reqwest::Error),
    /// A server error either due to the data, or with the connection.
    #[error(transparent)]
    CommunicationError(#[from] reqwest_middleware::Error),
    #[error(transparent)]
    Serde(#[from] serde_json::Error),
    /// An invalid URL was provided.
    #[error(transparent)]
    UrlParseError(#[from] url::ParseError),
    #[error(transparent)]
    Io(#[from] std::io::Error),
    /// There is an error in provided credentials.
    #[error("Credential error: {0}")]
    CredentialsConfigError(String),
    #[error("ApiError: {0}")]
    ApiError(ResponseContent),
    #[error("UnexpectedStatusCode: {0}")]
    UnexpectedStatusCode(reqwest::StatusCode),
    #[error("Internal Error: {0}")]
    InternalError(String),
}

pub fn urlencode<T: AsRef<str>>(s: T) -> String {
    ::url::form_urlencoded::byte_serialize(s.as_ref().as_bytes()).collect()
}

pub fn parse_deep_object(prefix: &str, value: &serde_json::Value) -> Vec<(String, String)> {
    if let serde_json::Value::Object(object) = value {
        let mut params = vec![];

        for (key, value) in object {
            match value {
                serde_json::Value::Object(_) => params.append(&mut parse_deep_object(
                    &format!("{}[{}]", prefix, key),
                    value,
                )),
                serde_json::Value::Array(array) => {
                    for (i, value) in array.iter().enumerate() {
                        params.append(&mut parse_deep_object(
                            &format!("{}[{}][{}]", prefix, key, i),
                            value,
                        ));
                    }
                }
                serde_json::Value::String(s) => {
                    params.push((format!("{}[{}]", prefix, key), s.clone()))
                }
                _ => params.push((format!("{}[{}]", prefix, key), value.to_string())),
            }
        }

        return params;
    }

    unimplemented!("Only objects are supported with style=deepObject")
}

/// Internal use only
/// A content type supported by this client.
#[allow(dead_code)]
pub enum ContentType {
    Json,
    Text,
    Unsupported(String),
}

impl From<&str> for ContentType {
    fn from(content_type: &str) -> Self {
        if content_type.starts_with("application") && content_type.contains("json") {
            return Self::Json;
        } else if content_type.starts_with("text/plain") {
            return Self::Text;
        } else {
            return Self::Unsupported(content_type.to_string());
        }
    }
}

pub mod configuration;

use std::sync::Arc;

use crate::ConfigurationBuilder;

#[derive(Clone)]
pub struct OsClient {
    configuration: Arc<crate::Configuration>,
    // common_api: crate::common::CommonApi,
    #[cfg(feature = "asynchronous_search")]
    asynchronous_search_api: Arc<crate::asynchronous_search::AsynchronousSearchApi>,
    #[cfg(feature = "cat")]
    cat_api: Arc<crate::cat::CatApi>,
    #[cfg(feature = "cluster")]
    cluster_api: Arc<crate::cluster::ClusterApiClient>,
    #[cfg(feature = "dangling_indices")]
    dangling_indices_api: Arc<crate::dangling_indices::DanglingIndicesApi>,
    #[cfg(feature = "indices")]
    indices_api: Arc<crate::indices::IndicesApiClient>,
    #[cfg(feature = "ingest")]
    ingest_api: Arc<crate::ingest::IngestApiClient>,
    #[cfg(feature = "insights")]
    insights_api: Arc<crate::insights::InsightsApi>,
    #[cfg(feature = "ism")]
    ism_api: Arc<crate::ism::IsmApi>,
    #[cfg(feature = "knn")]
    knn_api: Arc<crate::knn::KnnApi>,
    #[cfg(feature = "ml")]
    ml_api: Arc<crate::ml::MlApiClient>,
    #[cfg(feature = "nodes")]
    nodes_api: Arc<crate::nodes::NodesApi>,
    #[cfg(feature = "notifications")]
    notifications_api: Arc<crate::notifications::NotificationsApi>,
    #[cfg(feature = "observability")]
    observability_api: Arc<crate::observability::ObservabilityApi>,
    #[cfg(feature = "ppl")]
    ppl_api: Arc<crate::ppl::PplApi>,
    #[cfg(feature = "remote_store")]
    remote_store_api: Arc<crate::remote_store::RemoteStoreApi>,
    #[cfg(feature = "replication")]
    replication_api: Arc<crate::replication::ReplicationApi>,
    #[cfg(feature = "rollups")]
    rollups_api: Arc<crate::rollups::RollupsApi>,
    #[cfg(feature = "security")]
    security_api: Arc<crate::security::SecurityApi>,
    #[cfg(feature = "snapshot")]
    snapshot_api: Arc<crate::snapshot::SnapshotApi>,
    #[cfg(feature = "sql")]
    sql_api: Arc<crate::sql::SqlApi>,
    #[cfg(feature = "tasks")]
    tasks_api: Arc<crate::tasks::TasksApi>,
    #[cfg(feature = "transforms")]
    transforms_api: Arc<crate::transforms::TransformsApi>,
}

#[bon]
impl OsClient {
    pub fn new(configuration: Arc<crate::Configuration>) -> Self {
        Self {
            configuration: configuration.clone(),
            #[cfg(feature = "asynchronous_search")]
            asynchronous_search_api: Arc::new(
                asynchronous_search::AsynchronousSearchApiClient::new(configuration.clone()),
            ),
            #[cfg(feature = "cat")]
            cat_api: Arc::new(crate::cat::CatApiClient::new(configuration.clone())),
            // common_api: Arc::new(crate::common::CommonApi::new(configuration.clone())),
            #[cfg(feature = "cluster")]
            cluster_api: Arc::new(crate::cluster::ClusterApiClient::new(configuration.clone())),
            #[cfg(feature = "dangling_indices")]
            dangling_indices_api: Arc::new(crate::dangling_indices::DanglingIndicesApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "indices")]
            indices_api: Arc::new(crate::indices::IndicesApiClient::new(configuration.clone())),
            #[cfg(feature = "ingest")]
            ingest_api: Arc::new(crate::ingest::IngestApiClient::new(configuration.clone())),
            #[cfg(feature = "insights")]
            insights_api: Arc::new(crate::insights::InsightsApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "ism")]
            ism_api: Arc::new(crate::ism::IsmApiClient::new(configuration.clone())),
            #[cfg(feature = "knn")]
            knn_api: Arc::new(crate::knn::KnnApiClient::new(configuration.clone())),
            #[cfg(feature = "ml")]
            ml_api: Arc::new(crate::ml::MlApiClient::new(configuration.clone())),
            #[cfg(feature = "nodes")]
            nodes_api: Arc::new(crate::nodes::NodesApiClient::new(configuration.clone())),
            #[cfg(feature = "notifications")]
            notifications_api: Arc::new(notifications::NotificationsApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "observability")]
            observability_api: Arc::new(observability::ObservabilityApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "ppl")]
            ppl_api: Arc::new(crate::ppl::PplApiClient::new(configuration.clone())),
            #[cfg(feature = "remote_store")]
            remote_store_api: Arc::new(remote_store::RemoteStoreApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "replication")]
            replication_api: Arc::new(replication::ReplicationApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "rollups")]
            rollups_api: Arc::new(crate::rollups::RollupsApiClient::new(configuration.clone())),
            #[cfg(feature = "security")]
            security_api: Arc::new(crate::security::SecurityApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "snapshot")]
            snapshot_api: Arc::new(crate::snapshot::SnapshotApiClient::new(
                configuration.clone(),
            )),
            #[cfg(feature = "sql")]
            sql_api: Arc::new(crate::sql::SqlApiClient::new(configuration.clone())),
            #[cfg(feature = "tasks")]
            tasks_api: Arc::new(crate::tasks::TasksApiClient::new(configuration.clone())),
            #[cfg(feature = "transforms")]
            transforms_api: Arc::new(crate::transforms::TransformsApiClient::new(
                configuration.clone(),
            )),
        }
    }
    pub fn from_environment() -> Result<OsClient, Error> {
        let accept_invalid_certificates: bool = match std::env::var("OPENSEARCH_SSL_VERIFY") {
            Ok(value) => value.eq_ignore_ascii_case("false"),
            Err(_) => false,
        };
        let user: String = match std::env::var("OPENSEARCH_USER") {
            Ok(user) => user,
            Err(_) => "admin".into(),
        };
        let password: String = match std::env::var("OPENSEARCH_PASSWORD") {
            Ok(password) => password,
            Err(_) => "admin".into(),
        };

        let server = match std::env::var("OPENSEARCH_URL") {
            Ok(server) => server,
            Err(_) => "https://localhost:9200".into(),
        };

        let mut builder = ConfigurationBuilder::new().base_url(Url::parse(&server)?);
        if accept_invalid_certificates {
            builder = builder.accept_invalid_certificates(true);
        }
        builder = builder.basic_auth(user, password);

        if let Ok(max_bulk_size) = std::env::var("OPENSEARCH_MAX_BULK_SIZE") {
            match max_bulk_size.parse::<u32>() {
                Ok(max_bulk_size) => builder = builder.max_bulk_size(max_bulk_size),
                Err(_) => {
                    tracing::info!("Invalid value for OPENSEARCH_MAX_BULK_SIZE, using default")
                }
            }
        };

        Ok(builder.build())
    }

    #[cfg(feature = "quickwit")]
    pub fn from_quickwit_environment() -> Result<OsClient, Error> {
        let accept_invalid_certificates: bool = match std::env::var("QUICKWIT_SSL_VERIFY") {
            Ok(value) => value.eq_ignore_ascii_case("false"),
            Err(_) => false,
        };

        let mut server = match std::env::var("QUICKWIT_URL") {
            Ok(server) => server,
            Err(_) => "http://localhost:7280".into(),
        };
        // api/v1/_elastic
        if !server.ends_with("/api/v1/_elastic") {
            server.push_str("/api/v1/_elastic");
        }

        let mut builder = ConfigurationBuilder::new().base_url(Url::parse(&server)?);
        if accept_invalid_certificates {
            builder = builder.accept_invalid_certificates(true);
        }

        if let Ok(max_bulk_size) = std::env::var("QUICKWIT_MAX_BULK_SIZE") {
            match max_bulk_size.parse::<u32>() {
                Ok(max_bulk_size) => builder = builder.max_bulk_size(max_bulk_size),
                Err(_) => info!("Invalid value for QUICKWIT_MAX_BULK_SIZE, using default"),
            }
        };

        Ok(builder.build())
    }

    // pub fn core(&self) -> &crate::common::CommonApi {
    //     &self.common_api
    // }

    #[cfg(feature = "indices")]
    pub fn indices(&self) -> &crate::indices::IndicesApiClient {
        &self.indices_api
    }
    #[cfg(feature = "cluster")]
    pub fn cluster(&self) -> &crate::cluster::ClusterApiClient {
        &self.cluster_api
    }
    #[cfg(feature = "asynchronous_search")]
    pub fn asynchronous_search(&self) -> &crate::asynchronous_search::AsynchronousSearchApi {
        &self.asynchronous_search_api
    }
    #[cfg(feature = "cat")]
    pub fn cat(&self) -> &crate::cat::CatApi {
        &self.cat_api
    }
    #[cfg(feature = "dangling_indices")]
    pub fn dangling_indices(&self) -> &crate::dangling_indices::DanglingIndicesApi {
        &self.dangling_indices_api
    }
    #[cfg(feature = "ingest")]
    pub fn ingest(&self) -> &crate::ingest::IngestApiClient {
        &self.ingest_api
    }
    #[cfg(feature = "insights")]
    pub fn insights(&self) -> &crate::insights::InsightsApi {
        &self.insights_api
    }
    #[cfg(feature = "ism")]
    pub fn ism(&self) -> &crate::ism::IsmApi {
        &self.ism_api
    }
    #[cfg(feature = "knn")]
    pub fn knn(&self) -> &crate::knn::KnnApi {
        &self.knn_api
    }
    #[cfg(feature = "ml")]
    pub fn ml(&self) -> &crate::ml::MlApiClient {
        &self.ml_api
    }
    #[cfg(feature = "nodes")]
    pub fn nodes(&self) -> &crate::nodes::NodesApi {
        &self.nodes_api
    }
    #[cfg(feature = "notifications")]
    pub fn notifications(&self) -> &crate::notifications::NotificationsApi {
        &self.notifications_api
    }
    #[cfg(feature = "observability")]
    pub fn observability(&self) -> &crate::observability::ObservabilityApi {
        &self.observability_api
    }
    #[cfg(feature = "ppl")]
    pub fn ppl(&self) -> &crate::ppl::PplApi {
        &self.ppl_api
    }
    #[cfg(feature = "remote_store")]
    pub fn remote_store(&self) -> &crate::remote_store::RemoteStoreApi {
        &self.remote_store_api
    }
    #[cfg(feature = "replication")]
    pub fn replication(&self) -> &crate::replication::ReplicationApi {
        &self.replication_api
    }
    #[cfg(feature = "rollups")]
    pub fn rollups(&self) -> &crate::rollups::RollupsApi {
        &self.rollups_api
    }
    #[cfg(feature = "security")]
    pub fn security(&self) -> &crate::security::SecurityApi {
        &self.security_api
    }
    #[cfg(feature = "snapshot")]
    pub fn snapshot(&self) -> &crate::snapshot::SnapshotApi {
        &self.snapshot_api
    }
    #[cfg(feature = "sql")]
    pub fn sql(&self) -> &crate::sql::SqlApi {
        &self.sql_api
    }
    #[cfg(feature = "tasks")]
    pub fn tasks(&self) -> &crate::tasks::TasksApi {
        &self.tasks_api
    }
    #[cfg(feature = "transforms")]
    pub fn transforms(&self) -> &crate::transforms::TransformsApi {
        &self.transforms_api
    }

    #[cfg(feature = "tools")]
    pub fn tools(&self) -> crate::tools::Tools {
        crate::tools::Tools::new(Arc::new(self.clone()))
    }

    ///
    /// Deletes a script.
    #[builder(on(String, into))]
    pub async fn delete_script(
        &self,
        cluster_manager_timeout: Option<String>,
        master_timeout: Option<String>,
        timeout: Option<String>,
        error_trace: Option<bool>,
        filter_path: Option<common::FilterPath>,
        human: Option<bool>,
        id: String,
        pretty: Option<bool>,
        source: Option<String>,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_scripts/{id}",
            local_var_configuration.base_path,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information and statistics about terms in the fields of a particular document.
    #[builder(on(String, into))]
    pub async fn termvectors(
        &self,
        /// Define parameters and or supply a document to get termvectors for. See documentation.
        termvectors: common::Termvectors,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        field_statistics: Option<bool>,
        /// No description available
        fields: Option<common::Fields>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        index: String,
        /// No description available
        offsets: Option<bool>,
        /// No description available
        payloads: Option<bool>,
        /// No description available
        positions: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        term_statistics: Option<bool>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<crate::common::TermvectorsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_termvectors/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = positions {
            local_var_req_builder =
                local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = offsets {
            local_var_req_builder =
                local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = term_statistics {
            local_var_req_builder =
                local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = field_statistics {
            local_var_req_builder =
                local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = payloads {
            local_var_req_builder =
                local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&termvectors);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns basic information about the cluster.
    #[builder(on(String, into))]
    pub async fn info(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::InfoResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about the indexes and shards that a search request would be executed against.
    #[builder(on(String, into))]
    pub async fn search_shards(
        &self,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        local: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
    ) -> Result<crate::common::SearchShardsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_search_shards", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or updates a script.
    #[builder(on(String, into))]
    pub async fn put_script(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        context: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The document
        put_script: common::PutScript,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_scripts/{id}/{context}",
            local_var_configuration.base_path,
            id = id,
            context = context.clone().unwrap_or_else(|| "painless".to_string())
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(local_var_str) = context {
            local_var_req_builder =
                local_var_req_builder.query(&[("context", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&put_script);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to evaluate the quality of ranked search results over a set of typical search queries.
    #[builder(on(String, into))]
    pub async fn rank_eval(
        &self,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        source: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The ranking evaluation search definition, including search requests, document ratings and ranking metric definition.
        rank_eval: common::RankEval,
    ) -> Result<crate::common::RankEvalResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_rank_eval",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&rank_eval);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about why a specific matches (or doesn't match) a query.
    #[builder(on(String, into))]
    pub async fn explain(
        &self,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        index: String,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        q: Option<String>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
        /// The query definition using the Query DSL
        explain: common::Explain,
    ) -> Result<crate::common::ExplainResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_explain/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&explain);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a script.
    #[builder(on(String, into))]
    pub async fn get_script(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::GetScriptResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_scripts/{id}",
            local_var_configuration.base_path,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to use the Mustache language to pre-render a search definition.
    #[builder(on(String, into))]
    pub async fn render_search_template(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The search definition template and its parameters.
        render_search_template: common::RenderSearchTemplate,
    ) -> Result<crate::common::RenderSearchTemplateResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_render/template/{id}",
            local_var_configuration.base_path,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&render_search_template);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to copy documents from one index to another, optionally filtering the source
    /// documents by a query, changing the destination index settings, or fetching the
    /// documents from a remote cluster.
    #[builder(on(String, into))]
    pub async fn reindex(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Maximum number of documents to process. By default, all documents.
        max_docs: Option<i32>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        require_alias: Option<bool>,
        /// No description available
        source: Option<String>,
        /// No description available
        wait_for_completion: Option<bool>,
        /// The search definition using the Query DSL and the prototype for the index request.
        reindex: common::Reindex,
        /// The slice configuration used to parallelize a process.
        slices: Option<common::Slices>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::common::ReindexOKJson, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_reindex", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_completion {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_docs {
            local_var_req_builder =
                local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = slices {
            local_var_req_builder =
                local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = require_alias {
            local_var_req_builder =
                local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&reindex);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about whether a document source exists in an index.
    #[builder(on(String, into))]
    pub async fn exists_source(
        &self,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        index: String,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<ExistsSourceSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_source/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes documents matching the provided query.
    #[builder(on(String, into))]
    pub async fn delete_by_query(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        search_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Deprecated, use `max_docs` instead.
        size: Option<i32>,
        /// No description available
        source_excludes: Option<Vec<String>>,
        /// No description available
        source_includes: Option<Vec<String>>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        conflicts: Option<String>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        from: Option<i32>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        max_docs: Option<i32>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        q: Option<String>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        request_cache: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        scroll_size: Option<i32>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        sort: Option<Vec<String>>,
        /// No description available
        source: Option<String>,
        /// No description available
        stats: Option<Vec<String>>,
        /// No description available
        terminate_after: Option<i32>,
        /// No description available
        version: Option<bool>,
        /// No description available
        wait_for_completion: Option<bool>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The search definition using the Query DSL
        delete_by_query: common::DeleteByQuery,
        /// The slice configuration used to parallelize a process.
        slices: Option<common::Slices>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::common::DeleteByQueryOKJson, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_delete_by_query",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = slices {
            local_var_req_builder =
                local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stats {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("stats".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "stats",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = max_docs {
            local_var_req_builder =
                local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_completion {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_includes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_includes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = conflicts {
            local_var_req_builder =
                local_var_req_builder.query(&[("conflicts", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = request_cache {
            local_var_req_builder =
                local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("sort".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "sort",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_excludes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_excludes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = from {
            local_var_req_builder =
                local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&delete_by_query);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about whether a document exists in an index.
    #[builder(on(String, into))]
    pub async fn exists(
        &self,
        /// No description available
        index: String,
        /// No description available
        id: String,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<ExistsSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_doc/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns the information about the capabilities of fields among multiple indexes.
    #[builder(on(String, into))]
    pub async fn field_caps(
        &self,
        /// An index filter specified with the Query DSL
        field_caps: common::FieldCaps,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        fields: Option<common::Fields>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        include_unmapped: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
    ) -> Result<crate::common::FieldCapsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_field_caps",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_unmapped {
            local_var_req_builder =
                local_var_req_builder.query(&[("include_unmapped", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&field_caps);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a document.
    #[builder(on(String, into))]
    pub async fn get(
        &self,
        /// No description available
        id: String,
        /// No description available
        index: String,

        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<crate::core::get::GetResult, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_doc/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            if local_var_status == reqwest::StatusCode::NOT_FOUND {
                return Err(Error::DocumentNotFoundError(index, id));
            } else {
                let local_var_error = ResponseContent {
                    status: local_var_status,
                    content: local_var_content,
                };
                Err(Error::ApiError(local_var_error))
            }
        }
    }
    ///
    /// Removes a document from the index.
    #[builder(on(String, into))]
    pub async fn delete(
        &self,
        /// No description available
        index: String,
        /// No description available
        id: String,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        if_primary_term: Option<i32>,
        /// No description available
        if_seq_no: Option<i32>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<DocumentDeleteResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_doc/{id}",
            local_var_configuration.base_path,
            id = id,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = if_seq_no {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = if_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns multiple termvectors in one request.
    #[builder(on(String, into))]
    pub async fn mtermvectors(
        &self,
        /// Define ids, documents, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.
        mtermvectors: common::Mtermvectors,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        field_statistics: Option<bool>,
        /// No description available
        fields: Option<common::Fields>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ids: Option<Vec<String>>,
        /// No description available
        index: String,
        /// No description available
        offsets: Option<bool>,
        /// No description available
        payloads: Option<bool>,
        /// No description available
        positions: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        term_statistics: Option<bool>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<crate::common::MtermvectorsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_mtermvectors",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ids {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("ids".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "ids",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = positions {
            local_var_req_builder =
                local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = payloads {
            local_var_req_builder =
                local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = term_statistics {
            local_var_req_builder =
                local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = field_statistics {
            local_var_req_builder =
                local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = offsets {
            local_var_req_builder =
                local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&mtermvectors);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns results matching a query.
    #[builder(on(String, into))]
    pub async fn search_with_index(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cancel_after_time_interval: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Customizable sequence of processing stages applied to search queries.
        search_pipeline: Option<String>,
        /// Indicates whether `hit.matched_queries` should be rendered as a map that includes the name of the matched query associated with its score (true) or as an array containing the name of the matched queries (false)
        include_named_queries_score: Option<bool>,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        allow_partial_search_results: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        batched_reduce_size: Option<i32>,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        docvalue_fields: Option<common::DocvalueFields>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        explain: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        from: Option<i32>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_throttled: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        max_concurrent_shard_requests: Option<i32>,
        /// No description available
        phase_took: Option<bool>,
        /// No description available
        pre_filter_shard_size: Option<i32>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        q: Option<String>,
        /// No description available
        request_cache: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        seq_no_primary_term: Option<bool>,
        /// No description available
        size: Option<i32>,
        /// No description available
        sort: Option<common::Sort>,
        /// No description available
        source: Option<String>,
        /// No description available
        stats: Option<Vec<String>>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
        /// No description available
        suggest_mode: Option<String>,
        /// No description available
        suggest_size: Option<i32>,
        /// No description available
        suggest_text: Option<String>,
        /// No description available
        terminate_after: Option<i32>,
        /// No description available
        track_scores: Option<bool>,
        /// No description available
        typed_keys: Option<bool>,
        /// No description available
        version: Option<bool>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The number of hits matching the query. When `true`, the exact
        /// number of hits is returned at the cost of some performance. When `false`, the
        /// response does not include the total number of hits matching the query.
        /// Default is `10,000` hits.
        track_total_hits: Option<common::TrackTotalHits>,
        /// The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
        suggest_field: Option<String>,
        /// The search definition using the Query DSL
        search_with_index: common::SearchWithIndex,
    ) -> Result<SearchWithIndexSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_search",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_concurrent_shard_requests {
            local_var_req_builder = local_var_req_builder
                .query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cancel_after_time_interval {
            local_var_req_builder = local_var_req_builder
                .query(&[("cancel_after_time_interval", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = docvalue_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("docvalue_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_named_queries_score {
            local_var_req_builder = local_var_req_builder
                .query(&[("include_named_queries_score", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = explain {
            local_var_req_builder =
                local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder =
                local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_partial_search_results {
            local_var_req_builder = local_var_req_builder
                .query(&[("allow_partial_search_results", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_mode {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = track_scores {
            local_var_req_builder =
                local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = batched_reduce_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = request_cache {
            local_var_req_builder =
                local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_throttled {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_text {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = from {
            local_var_req_builder =
                local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pre_filter_shard_size {
            local_var_req_builder = local_var_req_builder
                .query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = track_total_hits {
            local_var_req_builder =
                local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = phase_took {
            local_var_req_builder =
                local_var_req_builder.query(&[("phase_took", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stats {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("stats".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "stats",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_field {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = seq_no_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&search_with_index);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to get multiple documents in one request.
    #[builder(on(String, into))]
    pub async fn mget(
        &self,
        /// No description available
        index: String,
        /// Document identifiers; can be either `docs` (containing full document information) or `ids` (when index is provided in the URL.
        mget: common::Mget,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
    ) -> Result<crate::common::MgetResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_mget",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&mget);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns available script types, languages and contexts.
    #[builder(on(String, into))]
    pub async fn get_script_languages(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::GetScriptLanguagesResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_script_language", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Explicitly clears the search context for a scroll.
    #[builder(on(String, into))]
    pub async fn clear_scroll(
        &self,
        /// Comma-separated list of scroll IDs to clear if none was specified using the `scroll_id` parameter
        clear_scroll: Option<common::ClearScroll>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        scroll_id: Option<String>,
        /// No description available
        source: Option<String>,
    ) -> Result<ClearScrollSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = if let Some(scroll_id) = &scroll_id {
            format!(
                "{}_search/scroll/{scroll_id}",
                local_var_configuration.base_path,
                scroll_id = scroll_id
            )
        } else {
            format!("{}_search/scroll", local_var_configuration.base_path)
        };
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&clear_scroll);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to use the Mustache language to pre-render a search definition.
    #[builder(on(String, into))]
    pub async fn search_template(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        explain: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_throttled: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        profile: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        source: Option<String>,
        /// No description available
        typed_keys: Option<bool>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The search definition template and its parameters.
        search_template: common::SearchTemplate,
    ) -> Result<crate::common::SearchTemplateResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_search/template", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_throttled {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = profile {
            local_var_req_builder =
                local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = explain {
            local_var_req_builder =
                local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&search_template);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns number of documents matching a query.
    #[builder(on(String, into))]
    pub async fn count(
        &self,
        /// No description available
        index: String,
        /// Query to restrict the results specified with the Query DSL (optional)
        count: Option<common::Count>,
        /// Query to restrict the results specified with the Query DSL (optional)
        query: Option<crate::dsl::Query>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_throttled: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        min_score: Option<f64>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        q: Option<String>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        terminate_after: Option<i32>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
    ) -> Result<crate::common::CountResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_count",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_score {
            local_var_req_builder =
                local_var_req_builder.query(&[("min_score", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_throttled {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        let mut count = count;
        if let Some(ref query) = query {
            count = Some(common::Count {
                query: Some(query.clone()),
            });
        }

        if let Some(ref body) = count {
            local_var_req_builder = local_var_req_builder.json(&body);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about the indexes and shards that a search request would be executed against.
    #[builder(on(String, into))]
    pub async fn search_shards_with_index(
        &self,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        local: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
    ) -> Result<crate::common::SearchShardsWithIndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_search_shards",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Changes the number of requests per second for a particular reindex operation.
    #[builder(on(String, into))]
    pub async fn reindex_rethrottle(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        source: Option<String>,
        /// No description available
        task_id: String,
    ) -> Result<crate::common::ReindexRethrottleResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_reindex/{task_id}/_rethrottle",
            local_var_configuration.base_path,
            task_id = task_id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates a new document in the index.
    ///
    /// Returns a 409 response when a document with a same ID already exists in the index.
    #[builder(on(String, into))]
    pub async fn create(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        index: String,
        /// No description available
        pipeline: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
        /// The document
        body: serde_json::Value,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_create/{id}",
            local_var_configuration.base_path,
            id = id,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            if local_var_status.as_u16() == 409 {
                Err(Error::DocumentAlreadyExistsError(
                    index.to_string(),
                    id.to_string(),
                ))
            } else {
                let local_var_error = ResponseContent {
                    status: local_var_status,
                    content: local_var_content,
                };
                Err(Error::ApiError(local_var_error))
            }
        }
    }
    ///
    /// Returns results matching a query.
    #[builder(on(String, into))]
    pub async fn search(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cancel_after_time_interval: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Customizable sequence of processing stages applied to search queries.
        search_pipeline: Option<String>,
        /// Indicates whether `hit.matched_queries` should be rendered as a map that includes the name of the matched query associated with its score (true) or as an array containing the name of the matched queries (false)
        include_named_queries_score: Option<bool>,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        allow_partial_search_results: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        batched_reduce_size: Option<i32>,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        docvalue_fields: Option<common::DocvalueFields>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        explain: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        from: Option<i32>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_throttled: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        max_concurrent_shard_requests: Option<i32>,
        /// No description available
        phase_took: Option<bool>,
        /// No description available
        pre_filter_shard_size: Option<i32>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        q: Option<String>,
        /// No description available
        request_cache: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        seq_no_primary_term: Option<bool>,
        /// No description available
        size: Option<i32>,
        /// No description available
        sort: Option<common::Sort>,
        /// No description available
        source: Option<String>,
        /// No description available
        stats: Option<Vec<String>>,
        /// No description available
        stored_fields: Option<common::StoredFields>,
        /// No description available
        suggest_mode: Option<String>,
        /// No description available
        suggest_size: Option<i32>,
        /// No description available
        suggest_text: Option<String>,
        /// No description available
        terminate_after: Option<i32>,
        /// No description available
        track_scores: Option<bool>,
        /// No description available
        typed_keys: Option<bool>,
        /// No description available
        version: Option<bool>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The number of hits matching the query. When `true`, the exact
        /// number of hits is returned at the cost of some performance. When `false`, the
        /// response does not include the total number of hits matching the query.
        /// Default is `10,000` hits.
        track_total_hits: Option<common::TrackTotalHits>,
        /// The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
        suggest_field: Option<String>,
        index: Option<String>,
        /// The search definition using the Query DSL
        search: Option<common::Search>,
    ) -> Result<SearchSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = if let Some(index) = &index {
            format!("{}{}/_search", local_var_configuration.base_path, index)
        } else {
            format!("{}_search", local_var_configuration.base_path)
        };
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_named_queries_score {
            local_var_req_builder = local_var_req_builder
                .query(&[("include_named_queries_score", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = batched_reduce_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = phase_took {
            local_var_req_builder =
                local_var_req_builder.query(&[("phase_took", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = seq_no_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_text {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = track_scores {
            local_var_req_builder =
                local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = track_total_hits {
            local_var_req_builder =
                local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_concurrent_shard_requests {
            local_var_req_builder = local_var_req_builder
                .query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = docvalue_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("docvalue_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_partial_search_results {
            local_var_req_builder = local_var_req_builder
                .query(&[("allow_partial_search_results", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder =
                local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_mode {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = from {
            local_var_req_builder =
                local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pre_filter_shard_size {
            local_var_req_builder = local_var_req_builder
                .query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stats {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("stats".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "stats",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cancel_after_time_interval {
            local_var_req_builder = local_var_req_builder
                .query(&[("cancel_after_time_interval", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = explain {
            local_var_req_builder =
                local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stored_fields {
            local_var_req_builder =
                local_var_req_builder.query(&[("stored_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_throttled {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = suggest_field {
            local_var_req_builder =
                local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = request_cache {
            local_var_req_builder =
                local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }

        if let Some(ref body) = search {
            local_var_req_builder = local_var_req_builder.json(&body);
        }
        tracing::debug!(
            "Request: \npath:{}\n {}\n",
            local_var_uri_str,
            serde_json::to_string(&search).unwrap_or_default()
        );

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns the source of a document.
    #[builder(on(String, into))]
    pub async fn get_source(
        &self,
        /// No description available
        index: String,
        /// No description available
        id: String,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        realtime: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
    ) -> Result<GetSourceSuccess, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_source/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = realtime {
            local_var_req_builder =
                local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to perform multiple index/update/delete operations in a single request.
    #[builder(on(String, into))]
    pub async fn bulk(
        &self,
        /// The operation definition and data (action-data pairs), separated by newlines
        body: String,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Default document type for items which don't provide one.
        r#type: Option<String>,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pipeline: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        require_alias: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::bulk::BulkResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_bulk", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = require_alias {
            local_var_req_builder =
                local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder
            .body(reqwest::Body::from(body))
            .header("Content-Type", "application/x-ndjson");

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to retrieve a large numbers of results from a single search request.
    #[builder(on(String, into))]
    pub async fn scroll(
        &self,
        scroll: common::Scroll,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        scroll_id: Option<String>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::core::search::ResponseBody, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_search/scroll/{scroll_id}",
            local_var_configuration.base_path,
            scroll_id = scroll_id.clone().unwrap_or_default()
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll_id", &local_var_str.to_string())]);
        }
        local_var_req_builder = local_var_req_builder.query(&[("scroll", &scroll.to_string())]);
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&scroll);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to execute several search operations in one request.
    #[builder(on(String, into))]
    pub async fn msearch(
        &self,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        max_concurrent_searches: Option<i32>,
        /// No description available
        max_concurrent_shard_requests: Option<i32>,
        /// No description available
        pre_filter_shard_size: Option<i32>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        source: Option<String>,
        /// No description available
        typed_keys: Option<bool>,
    ) -> Result<crate::core::msearch::MultiSearchResult, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_msearch",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_concurrent_searches {
            local_var_req_builder = local_var_req_builder
                .query(&[("max_concurrent_searches", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_concurrent_shard_requests {
            local_var_req_builder = local_var_req_builder
                .query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pre_filter_shard_size {
            local_var_req_builder = local_var_req_builder
                .query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows an arbitrary script to be executed and a result to be returned.
    #[builder(on(String, into))]
    pub async fn scripts_painless_execute(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The script to execute
        scripts_painless_execute: common::ScriptsPainlessExecute,
    ) -> Result<crate::common::ScriptsPainlessExecuteResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_scripts/painless/_execute",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&scripts_painless_execute);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Performs an update on every document in the index without changing the source,
    /// for example to pick up a mapping change.
    #[builder(on(String, into))]
    pub async fn update_by_query(
        &self,
        index: String,
        /// The search definition using the Query DSL
        body: common::UpdateByQuery,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        search_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Deprecated, use `max_docs` instead.
        size: Option<i32>,
        /// No description available
        source_excludes: Option<Vec<String>>,
        /// No description available
        source_includes: Option<Vec<String>>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        conflicts: Option<String>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        from: Option<i32>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        max_docs: Option<i32>,
        /// No description available
        pipeline: Option<String>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        request_cache: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        scroll_size: Option<i32>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        sort: Option<Vec<String>>,
        /// No description available
        source: Option<String>,
        /// No description available
        stats: Option<Vec<String>>,
        /// No description available
        terminate_after: Option<i32>,
        /// No description available
        version: Option<bool>,
        /// No description available
        wait_for_completion: Option<bool>,
        /// Query in the Lucene query string syntax.
        q: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The slice configuration used to parallelize a process.
        slices: Option<common::Slices>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::common::UpdateByQueryOKJson, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_update_by_query",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = conflicts {
            local_var_req_builder =
                local_var_req_builder.query(&[("conflicts", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_includes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_includes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stats {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("stats".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "stats",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_excludes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_excludes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = slices {
            local_var_req_builder =
                local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = from {
            local_var_req_builder =
                local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = request_cache {
            local_var_req_builder =
                local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_completion {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_docs {
            local_var_req_builder =
                local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("sort".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "sort",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_timeout", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Performs an update on every document in the index without changing the source,
    /// for example to pick up a mapping change.
    #[builder(on(String, into))]
    pub async fn update_by_query_raw(
        &self,
        index: String,
        /// The search definition using the Query DSL
        body: serde_json::Value,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        search_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Deprecated, use `max_docs` instead.
        size: Option<i32>,
        /// No description available
        source_excludes: Option<Vec<String>>,
        /// No description available
        source_includes: Option<Vec<String>>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        analyze_wildcard: Option<bool>,
        /// No description available
        analyzer: Option<String>,
        /// No description available
        conflicts: Option<String>,
        /// No description available
        default_operator: Option<String>,
        /// No description available
        df: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        from: Option<i32>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        lenient: Option<bool>,
        /// No description available
        max_docs: Option<i32>,
        /// No description available
        pipeline: Option<String>,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        request_cache: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        scroll_size: Option<i32>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        sort: Option<Vec<String>>,
        /// No description available
        source: Option<String>,
        /// No description available
        stats: Option<Vec<String>>,
        /// No description available
        terminate_after: Option<i32>,
        /// No description available
        version: Option<bool>,
        /// No description available
        wait_for_completion: Option<bool>,
        /// Query in the Lucene query string syntax.
        q: Option<String>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The slice configuration used to parallelize a process.
        slices: Option<common::Slices>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::common::UpdateByQueryOKJson, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_update_by_query",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = conflicts {
            local_var_req_builder =
                local_var_req_builder.query(&[("conflicts", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_includes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_includes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll_size {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyze_wildcard {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stats {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("stats".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "stats",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lenient {
            local_var_req_builder =
                local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = analyzer {
            local_var_req_builder =
                local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = terminate_after {
            local_var_req_builder =
                local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("source_excludes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "source_excludes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = slices {
            local_var_req_builder =
                local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = from {
            local_var_req_builder =
                local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = request_cache {
            local_var_req_builder =
                local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_completion {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_docs {
            local_var_req_builder =
                local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("sort".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "sort",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = default_operator {
            local_var_req_builder =
                local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = df {
            local_var_req_builder =
                local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_timeout", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Changes the number of requests per second for a particular Update By Query operation.
    #[builder(on(String, into))]
    pub async fn update_by_query_rethrottle(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        source: Option<String>,
        /// No description available
        task_id: String,
    ) -> Result<crate::common::UpdateByQueryRethrottleResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_update_by_query/{task_id}/_rethrottle",
            local_var_configuration.base_path,
            task_id = task_id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns all script contexts.
    #[builder(on(String, into))]
    pub async fn get_script_context(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::GetScriptContextResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_script_context", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Changes the number of requests per second for a particular Delete By Query operation.
    #[builder(on(String, into))]
    pub async fn delete_by_query_rethrottle(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        requests_per_second: Option<f64>,
        /// No description available
        source: Option<String>,
        /// No description available
        task_id: String,
    ) -> Result<crate::tasks::TaskListResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_delete_by_query/{task_id}/_rethrottle",
            local_var_configuration.base_path,
            task_id = task_id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = requests_per_second {
            local_var_req_builder =
                local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to use the Mustache language to pre-render a search definition.
    #[builder(on(String, into))]
    pub async fn search_template_with_index(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        scroll: Option<String>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        explain: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_throttled: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        preference: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        profile: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        source: Option<String>,
        /// No description available
        typed_keys: Option<bool>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The search definition template and its parameters.
        search_template_with_index: common::SearchTemplateWithIndex,
    ) -> Result<crate::common::SearchTemplateWithIndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_search/template",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = profile {
            local_var_req_builder =
                local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_throttled {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = preference {
            local_var_req_builder =
                local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = scroll {
            local_var_req_builder =
                local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = explain {
            local_var_req_builder =
                local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&search_template_with_index);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to execute several search template operations in one request.
    #[builder(on(String, into))]
    pub async fn msearch_template(
        &self,
        /// No description available
        ccs_minimize_roundtrips: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        max_concurrent_searches: Option<i32>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        rest_total_hits_as_int: Option<bool>,
        /// No description available
        search_type: Option<common::SearchType>,
        /// No description available
        source: Option<String>,
        /// No description available
        typed_keys: Option<bool>,
    ) -> Result<crate::core::msearch::MultiSearchResult, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_msearch/template",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = typed_keys {
            local_var_req_builder =
                local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = max_concurrent_searches {
            local_var_req_builder = local_var_req_builder
                .query(&[("max_concurrent_searches", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = rest_total_hits_as_int {
            local_var_req_builder = local_var_req_builder
                .query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ccs_minimize_roundtrips {
            local_var_req_builder = local_var_req_builder
                .query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns whether the cluster is running.
    #[builder(on(String, into))]
    pub async fn ping(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<serde_json::Value, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or updates a document in an index.
    #[builder(on(String, into))]
    pub async fn index(
        &self,
        /// No description available
        index: String,
        body: serde_json::Value,
        /// No description available
        id: Option<String>,

        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        if_primary_term: Option<i32>,
        /// No description available
        if_seq_no: Option<i32>,
        /// No description available
        op_type: Option<String>,
        /// No description available
        pipeline: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        require_alias: Option<bool>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// No description available
        version: Option<i32>,
        /// No description available
        version_type: Option<String>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = if let Some(id) = id {
            format!(
                "{}{index}/_doc/{id}",
                local_var_configuration.base_path,
                index = index,
                id = id
            )
        } else {
            format!(
                "{}{index}/_doc",
                local_var_configuration.base_path,
                index = index
            )
        };
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());
        local_var_req_builder = local_var_req_builder.json(&body);

        if let Some(ref local_var_str) = if_seq_no {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pipeline {
            local_var_req_builder =
                local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = if_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version {
            local_var_req_builder =
                local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = require_alias {
            local_var_req_builder =
                local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = version_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = op_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("op_type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates a document with a script or partial document.
    #[builder(on(String, into))]
    pub async fn update(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        if_primary_term: Option<i32>,
        /// No description available
        if_seq_no: Option<i32>,
        /// No description available
        index: String,
        /// No description available
        lang: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        require_alias: Option<bool>,
        /// No description available
        retry_on_conflict: Option<i32>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// The request definition requires either `script` or partial `doc`
        update: common::Update,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_update/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = if_seq_no {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = if_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = retry_on_conflict {
            local_var_req_builder =
                local_var_req_builder.query(&[("retry_on_conflict", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = require_alias {
            local_var_req_builder =
                local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lang {
            local_var_req_builder =
                local_var_req_builder.query(&[("lang", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&update);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }

    ///
    /// Updates a document with a script or partial document.
    #[builder(on(String, into))]
    pub async fn update_raw(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        source_excludes: Option<common::SourceExcludes>,
        /// No description available
        source_includes: Option<common::SourceIncludes>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        id: String,
        /// No description available
        if_primary_term: Option<i32>,
        /// No description available
        if_seq_no: Option<i32>,
        /// No description available
        index: String,
        /// No description available
        lang: Option<String>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        refresh: Option<common::Refresh>,
        /// No description available
        require_alias: Option<bool>,
        /// No description available
        retry_on_conflict: Option<i32>,
        /// No description available
        routing: Option<common::Routing>,
        /// No description available
        source: Option<String>,
        /// The request definition requires either `script` or partial `doc`
        update: serde_json::Value,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}{index}/_update/{id}",
            local_var_configuration.base_path,
            index = index,
            id = id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = if_seq_no {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = refresh {
            local_var_req_builder =
                local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = routing {
            local_var_req_builder =
                local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = if_primary_term {
            local_var_req_builder =
                local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = retry_on_conflict {
            local_var_req_builder =
                local_var_req_builder.query(&[("retry_on_conflict", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_includes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_includes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source_excludes {
            local_var_req_builder =
                local_var_req_builder.query(&[("source_excludes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = require_alias {
            local_var_req_builder =
                local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = lang {
            local_var_req_builder =
                local_var_req_builder.query(&[("lang", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&update);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "2025-07-22"
    }

    /// Sends a bulk index request to OpenSearch with the specified index, id and
    /// document body.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index.
    /// * `id` - An optional string slice that holds the id of the document.
    /// * `body` - A reference to a serializable document body.
    ///
    /// # Returns
    ///
    /// Returns a Result containing a serde_json::Value representing the response
    /// from OpenSearch or an Error if the request fails.
    ///
    /// # Example
    ///
    /// ```
    /// use opensearch_client::OpenSearchClient;
    ///
    /// #[derive(Serialize)]
    /// struct MyDocument {
    ///   title: String,
    ///   content: String,
    /// }
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = OpenSearchClient::new("http://localhost:9200");
    ///   let document = MyDocument {
    ///     title: "My Title".to_string(),
    ///     content: "My Content".to_string(),
    ///   };
    ///   let response = client
    ///     .bulk_index_document("my_index", Some("my_id".to_string()), &document)
    ///     .await?;
    ///   Ok(())
    /// }
    /// ```
    pub async fn bulk_index_document<T: Serialize>(
        &self,
        index: &str,
        id: Option<String>,
        body: &T,
    ) -> Result<(), Error> {
        let body_json = serde_json::to_value(body)?;
        let action = BulkAction::Index(IndexAction {
            index: index.to_owned(),
            id: id.clone(),
            pipeline: None,
        });
        self.bulk_action(action, Some(&body_json)).await
    }

    /// Sends a bulk action to the OpenSearch server.
    ///
    /// # Arguments
    ///
    /// * `command` - A string slice that holds the command to be executed.
    /// * `action` - A `BulkAction` enum that specifies the action to be taken.
    /// * `body` - An optional `serde_json::Value` that holds the request body.
    ///
    /// # Returns
    ///
    /// A `Result` containing a `serde_json::Value` object representing the
    /// response from the server, or an `Error` if the request failed.
    ///
    /// # Examples
    ///
    /// ```
    /// use opensearch_client::{BulkAction, OpenSearchClient};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = OpenSearchClient::new("http://localhost:9200")?;
    ///   let action = BulkAction::Index {
    ///     index: "my_index".to_string(),
    ///     id: Some("1".to_string()),
    ///   };
    ///   let response = client.bulk_action("index", action, None).await?;
    ///   Ok(())
    /// }
    /// ```
    pub async fn bulk_action(
        &self,
        action: BulkAction,
        body: Option<&serde_json::Value>,
    ) -> Result<(), Error> {
        let j = serde_json::to_string(&action)?;
        let bulker_arc = Arc::clone(&self.configuration.bulker);
        let mut bulker = bulker_arc.lock().unwrap();
        bulker.push_str(j.as_str());
        bulker.push('\n');
        match body {
            None => {}
            Some(js) => {
                let j = serde_json::to_string(js)?;
                bulker.push_str(j.as_str());
                bulker.push('\n');
            }
        }

        let bulker_size_arc = Arc::clone(&self.configuration.bulker_size);
        let mut bulker_size = bulker_size_arc.lock().unwrap();
        *bulker_size += 1;
        if *bulker_size >= self.configuration.max_bulk_size {
            drop(bulker_size);
            drop(bulker);
            self.flush_bulk().await?;
        }
        Ok(())
    }

    /// Sends a bulk create request to the OpenSearch cluster with the specified
    /// index, id and body.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index.
    /// * `id` - A string slice that holds the id of the document.
    /// * `body` - A generic type `T` that holds the body of the document to be
    ///   created.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `serde_json::Value` on success, or an
    /// `Error` on failure.
    pub async fn bulk_create_document<T: Serialize>(
        &self,
        index: &str,
        id: &str,
        body: &T,
    ) -> Result<(), Error> {
        let body_json = serde_json::to_value(body)?;

        let action = BulkAction::Create(CreateAction {
            index: index.to_owned(),
            id: id.to_owned(),
            ..Default::default()
        });

        self.bulk_action(action, Some(&body_json)).await
    }

    /// Asynchronously updates a document in bulk.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index.
    /// * `id` - A string slice that holds the ID of the document to update.
    /// * `body` - An `UpdateAction` struct that holds the update action to
    ///   perform.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `serde_json::Value` on success, or an
    /// `Error` on failure.
    pub async fn bulk_update_document(
        &self,
        index: &str,
        id: &str,
        body: &UpdateActionBody,
    ) -> Result<(), Error> {
        let action = BulkAction::Update(UpdateAction {
            index: index.to_owned(),
            id: id.to_owned(),
            ..Default::default()
        });
        let j = serde_json::to_value(body)?;
        self.bulk_action(action, Some(&j)).await
    }

    /// Sends a bulk request to the OpenSearch server and returns a
    /// `BulkResponse`. If the bulker size is 0, it returns an empty
    /// `BulkResponse`. If the bulk request contains errors, it logs the errors
    /// and returns the `BulkResponse`.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use opensearch_client::OpenSearchClient;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = OpenSearchClient::new("http://localhost:9200", "user", "password");
    ///   let response = client.flush_bulk().await?;
    ///   println!("{:?}", response);
    ///   Ok(())
    /// }
    /// ```
    pub async fn flush_bulk(&self) -> Result<BulkResponse, Error> {
        let bulker_size_arc = Arc::clone(&self.configuration.bulker_size);
        let mut bulker_size = bulker_size_arc.lock().unwrap();
        if *bulker_size > 0 {
            let bulker_arc = Arc::clone(&self.configuration.bulker);
            let mut bulker = bulker_arc.lock().unwrap();

            // let request_url = format!("{}_bulk", self.server);

            match self.bulk().body(bulker.to_owned()).call().await
        // .client
        // .post(request_url)
        // .basic_auth(self.user.as_str(), Some(self.password.as_str()))
        // .body()
        // .header("Content-Type", "application/x-ndjson")
        // .send()
        // .await
      {
        Ok(result) => {
          *bulker = String::new();
          *bulker_size = 0;
          // debug!("{:?}", &result);
          if result.errors {
            for map in &result.items {
              for (_, value) in map.iter() {
                if let Some(error) = &value.error {
                  if !error.kind.eq_ignore_ascii_case("version_conflict_engine_exception") {
                    tracing::trace!("{:?}", &value);
                  }
                }
              }
            }
          }

          Ok(result)
        }
        Err(err) => {
          println!("{:?}", &err);
          Err(err)
        }
      }
        } else {
            Ok(BulkResponse {
                took: 0,
                errors: false,
                items: vec![],
                ingest_took: None,
            })
        }
    }

    /// Indexes a document in the specified index with the given body and optional
    /// ID.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index to which the
    ///   document will be added.
    /// * `body` - A reference to a serializable object that represents the
    ///   document to be added.
    /// * `id` - An optional string slice that holds the ID of the document to be
    ///   added. If not provided, a new ID will be generated.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `IndexResponse` object if the operation was
    /// successful, or an `Error` if an error occurred.
    ///
    /// # Examples
    ///
    /// ```
    /// use opensearch_client::Client;
    ///
    /// #[derive(Serialize)]
    /// struct MyDocument {
    ///   title: String,
    ///   content: String,
    /// }
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = Client::new("http://localhost:9200")?;
    ///
    ///   let document = MyDocument {
    ///     title: "My Title".to_string(),
    ///     content: "My Content".to_string(),
    ///   };
    ///
    ///   let response = client.index_document("my_index", &document, None).await?;
    ///
    ///   println!("Document ID: {}", response._id);
    ///
    ///   Ok(())
    /// }
    /// ```
    pub async fn index_document<T: Serialize>(
        &self,
        index: &str,
        body: &T,
        id: Option<String>,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let body_json = serde_json::to_value(body)?;
        let partial_request = self.index().index(index).body(body_json).maybe_id(id);
        let response = partial_request.call().await?;
        Ok(response)
    }

    /// Creates a new document in the specified index with the given ID and body.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index.
    /// * `id` - A string slice that holds the ID of the document.
    /// * `body` - A generic type `T` that holds the body of the document. The
    ///   type `T` must implement the `Serialize` trait from the `serde` crate.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing an `IndexResponse` on success, or an `Error`
    /// on failure.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use opensearch_client::OpenSearchClient;
    ///
    /// #[derive(Serialize)]
    /// struct MyDocument {
    ///   title: String,
    ///   content: String,
    /// }
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = OpenSearchClient::new("http://localhost:9200")?;
    ///
    ///   let document = MyDocument {
    ///     title: "My Title".to_string(),
    ///     content: "My Content".to_string(),
    ///   };
    ///
    ///   let response = client.create_document("my_index", "1", &document).await?;
    ///
    ///   Ok(())
    /// }
    /// ```
    pub async fn create_document<T: Serialize>(
        &self,
        index: &str,
        id: &str,
        body: &T,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let body_json = serde_json::to_value(body)?;

        let response = self
            .create()
            .index(index)
            .id(id)
            .body(body_json)
            .call()
            .await?;

        Ok(response)
    }

    /// Asynchronously retrieves a typed document from the specified index and ID.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index to retrieve
    ///   the document from.
    /// * `id` - A string slice that holds the ID of the document to retrieve.
    ///
    /// # Returns
    ///
    /// A `Result` containing the deserialized content of the retrieved document,
    /// or an `Error` if the operation failed.
    ///
    /// # Generic Type Parameters
    ///
    /// * `T` - The type of the document to retrieve. Must implement the
    ///   `DeserializeOwned` and
    /// `std::default::Default` traits.
    pub async fn get_typed<T: DeserializeOwned + std::default::Default>(
        &self,
        index: &str,
        id: &str,
    ) -> Result<crate::core::get::GetTypedResult<T>, Error> {
        let response = self.get().index(index).id(id).call().await?;
        let result = response.parse::<T>()?;

        Ok(result)
    }

    /// Updates a document in the specified index with the given ID using the
    /// provided update action.
    ///
    /// # Arguments
    ///
    /// * `index` - A string slice that holds the name of the index to update the
    ///   document in.
    /// * `id` - A string slice that holds the ID of the document to update.
    /// * `action` - A reference to an `UpdateAction` enum that specifies the
    ///   update action to perform.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing an `IndexResponse` struct if the update was
    /// successful, or an `Error` if an error occurred.
    ///
    /// # Example
    ///
    /// ```rust
    /// use opensearch_client::{Client, UpdateAction};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///     let client = Client::new("http://localhost:9200")?;
    ///
    ///     let index = "my_index";
    ///     let id = "1";
    ///     let action = UpdateAction::new().doc(json!({"foo": "bar"}));
    ///
    ///     let response = client.update_document(index, id, &action).await?;
    ///
    ///     Ok(())
    /// }
    /// ```
    pub async fn update_document(
        &self,
        index: &str,
        id: &str,
        action: &UpdateActionBody,
    ) -> Result<crate::bulk::IndexResponse, Error> {
        let body = serde_json::to_value(&action)?;

        let response = self
            .update_raw()
            .update(body)
            .index(index)
            .id(id)
            .call()
            .await?;
        Ok(response)
    }

    pub fn get_bulker(
        &self,
        bulk_size: u32,
        max_concurrent_connections: u32,
    ) -> (JoinHandle<()>, Bulker) {
        Bulker::new(
            Arc::new(self.clone()),
            bulk_size,
            max_concurrent_connections,
        )
    }

    pub fn bulker(&self) -> BulkerBuilder {
        BulkerBuilder::new(Arc::new(self.clone()), self.configuration.max_bulk_size)
    }

    pub async fn search_typed<T: DeserializeOwned + std::default::Default>(
        &self,
        index: &str,
        search: Search,
    ) -> Result<crate::search::TypedSearchResult<T>, Error> {
        let response = self.search().index(index).search(search).call().await?;
        crate::search::TypedSearchResult::from_response(response)
    }

    /// Searches for documents in the specified index and returns a stream of
    /// hits.
    ///
    /// # Arguments
    ///
    /// * `index` - The name of the index to search in.
    /// * `query` - The query to execute.
    /// * `sort` - The sort criteria to use.
    /// * `size` - The maximum number of hits to return.
    ///
    /// # Returns
    ///
    /// A stream of hits that match the specified search criteria.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use opensearch_client::{Client, Query, SortCollection};
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {
    ///   let client = Client::new("http://localhost:9200")?;
    ///   let query = Query::match_all();
    ///   let sort = SortCollection::new().add_field("_doc", "asc");
    ///   let stream = client.search_stream("my_index", &query, &sort, 10).await?;
    ///   stream
    ///     .for_each(|hit| {
    ///       println!("{:?}", hit);
    ///       futures::future::ready(())
    ///     })
    ///     .await;
    ///   Ok(())
    /// }
    /// ```
    pub async fn search_stream<T: DeserializeOwned + std::default::Default>(
        &self,
        index: &str,
        query: &Query,
        sort: &SortCollection,
        size: u64,
    ) -> Result<impl Stream<Item = crate::search::TypedHit<T>> + 'static, Error> {
        let start_state = crate::search::SearchAfterState {
            client: Arc::new(self.clone()),
            stop: false,
            search_after: None,
            index: index.to_owned(),
            query: query.clone(),
            sort: sort.clone(),
            size,
        };

        async fn stream_next<T: DeserializeOwned + std::default::Default>(
            state: crate::search::SearchAfterState,
        ) -> Result<
            (
                Vec<crate::search::TypedHit<T>>,
                crate::search::SearchAfterState,
            ),
            Error,
        > {
            let mut body: Search = Search::new()
                .size(state.size)
                .query(state.query.clone())
                .sort(state.sort.clone());

            if let Some(search_after) = state.search_after.clone() {
                body = body.search_after(search_after.clone());
            }
            let response = state
                .client
                .clone()
                .search()
                .index(&state.index)
                .search(body)
                .call()
                .await?;
            let hits = response
                .hits
                .hits
                .into_iter()
                .map(|hit| {
                    let typed_hit: crate::search::TypedHit<T> =
                        crate::search::TypedHit::from_hit(hit);
                    typed_hit
                })
                .collect::<Vec<_>>();
            let next_state = crate::search::SearchAfterState {
                stop: (hits.len() as u64) < state.size,
                search_after: hits.iter().last().and_then(|f| {
                    let last_sort = f.sort.clone();
                    if last_sort.is_empty() {
                        None
                    } else {
                        Some(opensearch_dsl::Terms::from(last_sort))
                    }
                }),
                ..state
            };

            Ok((hits, next_state))
        }

        let stream = stream::unfold(start_state, move |state| async move {
            if state.stop {
                None
            } else {
                let result = stream_next::<T>(state).await;
                match result {
                    Ok((items, state)) => Some((stream::iter(items), state)),
                    Err(_err) => None,
                }
            }
        });

        Ok(stream.flatten())
    }

    // pub async fn send<T: Request + Serialize>(
    //     &self,
    //     request: T,
    // ) -> Result<ResponseValue<T::Response>, Error> {
    //     let body = request.body()?;
    //     let url = request.url(self.configuration.base_path.clone().as_ref())?;
    //     let mut request_builder = self.configuration.client.request(request.method(), url);
    //     if let Some(body) = body {
    //         request_builder = request_builder.body(body);
    //     }
    //     let response = request_builder.send().await?;
    //     match response.status().as_u16() {
    //         200u16 => ResponseValue::from_response(response).await,
    //         _ => Err(Error::UnexpectedResponse(
    //             ReqwestResponse::from_response(response).await,
    //         )),
    //     }
    // }
}
