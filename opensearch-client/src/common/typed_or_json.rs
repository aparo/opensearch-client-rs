/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */

use serde::{de::DeserializeOwned, Deserialize, Serialize};

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[serde(bound(deserialize = "T: serde::de::DeserializeOwned"))]
#[serde(untagged)]
pub enum TypedOrJson<T>
where
    T: serde::de::DeserializeOwned + Serialize + Clone,
{
    TypedValue(T),
    RawValue(serde_json::Value),
}

impl<T> std::fmt::Display for TypedOrJson<T>
where
    T: DeserializeOwned + Serialize + Clone + std::fmt::Display,
{
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            TypedOrJson::RawValue(s) => write!(f, "{}", s),
            TypedOrJson::TypedValue(v) => write!(f, "{}", v),
        }
    }
}

impl<T> TypedOrJson<T>
where
    T: DeserializeOwned + Serialize + Clone,
{
    /// Convert to serde_json::Value for serialization
    pub fn to_json_value(&self) -> Result<serde_json::Value, serde_json::Error> {
        match self {
            TypedOrJson::RawValue(s) => Ok(s.clone()),
            TypedOrJson::TypedValue(v) => serde_json::to_value(v),
        }
    }
}

// Allow constructing TypedOrJson from serde_json::Value
impl<T> From<serde_json::Value> for TypedOrJson<T>
where
    T: DeserializeOwned + Serialize + Clone,
{
    fn from(s: serde_json::Value) -> Self {
        TypedOrJson::RawValue(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::{from_str, json, to_string};
    #[derive(Debug, Deserialize, Serialize)]
    struct WaitWrapper {
        #[serde(default = "default_wait")]
        wait: TypedOrJson<Vec<serde_json::Value>>,
    }

    fn default_wait() -> TypedOrJson<Vec<serde_json::Value>> {
        TypedOrJson::TypedValue(Vec::new())
    }

    #[test]
    fn test_deserialize_number() {
        let json = r#"{"wait": {"name":"0"}}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrJson::RawValue(json!({"name": "0"})));
    }

    #[test]
    fn test_deserialize_string() {
        let json = r#"{"wait": []}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrJson::TypedValue(Vec::new()));
    }

    #[test]
    fn test_default_value() {
        let json = r#"{}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrJson::TypedValue(Vec::new()));
    }

    #[test]
    fn test_from_conversions() {
        let a: TypedOrJson<Vec<serde_json::Value>> = json!({"name": "0"}).into();
        let b: TypedOrJson<Vec<serde_json::Value>> =
            TypedOrJson::TypedValue(vec![json!({"name": "0"})]);
        assert_eq!(a, TypedOrJson::RawValue(json!({"name": "0"})));
        assert_eq!(b, TypedOrJson::TypedValue(vec![json!({"name": "0"})]));
    }

    #[test]
    fn test_serialization() {
        let a = WaitWrapper {
            wait: json!({"name": "0"}).into(),
        };
        let b = WaitWrapper {
            wait: TypedOrJson::TypedValue(vec![json!({"name": "0"})]),
        };
        assert_eq!(to_string(&a).unwrap(), r#"{"wait":{"name":"0"}}"#);
        assert_eq!(to_string(&b).unwrap(), r#"{"wait":[{"name":"0"}]}"#);
    }

    #[test]
    fn test_with_different_types() {
        // Test with String type
        let string_typed: TypedOrJson<String> = TypedOrJson::TypedValue("hello".to_string());
        let string_raw: TypedOrJson<String> = json!("world").into();

        assert_eq!(string_typed.to_json_value().unwrap(), json!("hello"));
        assert_eq!(string_raw.to_json_value().unwrap(), json!("world"));

        // Test with i32 type
        let int_typed: TypedOrJson<i32> = TypedOrJson::TypedValue(42);
        let int_raw: TypedOrJson<i32> = json!(100).into();

        assert_eq!(int_typed.to_json_value().unwrap(), json!(42));
        assert_eq!(int_raw.to_json_value().unwrap(), json!(100));
    }
}
