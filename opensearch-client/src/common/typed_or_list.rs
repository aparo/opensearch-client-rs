/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */

use serde::{de::DeserializeOwned, Deserialize, Serialize};

#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[serde(bound(deserialize = "T: serde::de::DeserializeOwned"))]
#[serde(untagged)]
pub enum TypedOrList<T>
where
    T: serde::de::DeserializeOwned + Serialize + Clone,
{
    MultiValue(Vec<T>),
    SingleValue(T),
}

impl<T> std::fmt::Display for TypedOrList<T>
where
    T: DeserializeOwned + Serialize + Clone + std::fmt::Display,
{
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            TypedOrList::MultiValue(s) => write!(
                f,
                "{}",
                s.iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<String>>()
                    .join(", ")
            ),
            TypedOrList::SingleValue(v) => write!(f, "{}", v),
        }
    }
}

impl<T> TypedOrList<T>
where
    T: DeserializeOwned + Serialize + Clone,
{
    /// Convert to serde_json::Value for serialization
    pub fn to_json_value(&self) -> Result<serde_json::Value, serde_json::Error> {
        match self {
            TypedOrList::MultiValue(s) => serde_json::to_value(s),
            TypedOrList::SingleValue(v) => serde_json::to_value(v),
        }
    }

    /// Get as vector - convert single value to single-item vector
    pub fn as_vec(&self) -> Vec<T> {
        match self {
            TypedOrList::MultiValue(s) => s.clone(),
            TypedOrList::SingleValue(v) => vec![v.clone()],
        }
    }
}

// Allow constructing TypedOrList from T (single value)
impl<T> From<T> for TypedOrList<T>
where
    T: DeserializeOwned + Serialize + Clone,
{
    fn from(s: T) -> Self {
        TypedOrList::SingleValue(s)
    }
}

// Allow constructing TypedOrList from Vec<T> (multiple values)
impl<T> From<Vec<T>> for TypedOrList<T>
where
    T: DeserializeOwned + Serialize + Clone,
{
    fn from(s: Vec<T>) -> Self {
        TypedOrList::MultiValue(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::{from_str, json, to_string};
    #[derive(Debug, Deserialize, Serialize)]
    struct WaitWrapper {
        #[serde(default = "default_wait")]
        wait: TypedOrList<serde_json::Value>,
    }

    fn default_wait() -> TypedOrList<serde_json::Value> {
        TypedOrList::MultiValue(Vec::new())
    }

    #[test]
    fn test_deserialize_number() {
        let json = r#"{"wait": {"name":"0"}}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrList::SingleValue(json!({"name": "0"})));
    }

    #[test]
    fn test_deserialize_string() {
        let json = r#"{"wait": []}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrList::MultiValue(Vec::new()));
    }

    #[test]
    fn test_default_value() {
        let json = r#"{}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(obj.wait, TypedOrList::MultiValue(Vec::new()));
    }

    #[test]
    fn test_from_conversions() {
        let a: TypedOrList<serde_json::Value> = json!({"name": "0"}).into();
        let b: TypedOrList<serde_json::Value> = vec![json!({"name": "0"})].into();
        assert_eq!(a, TypedOrList::SingleValue(json!({"name": "0"})));
        assert_eq!(b, TypedOrList::MultiValue(vec![json!({"name": "0"})]));
    }

    #[test]
    fn test_serialization() {
        let a = WaitWrapper {
            wait: json!({"name": "0"}).into(),
        };
        let b = WaitWrapper {
            wait: TypedOrList::MultiValue(vec![json!({"name": "0"})]),
        };
        assert_eq!(to_string(&a).unwrap(), r#"{"wait":{"name":"0"}}"#);
        assert_eq!(to_string(&b).unwrap(), r#"{"wait":[{"name":"0"}]}"#);
    }

    #[test]
    fn test_with_different_types() {
        // Test with String type
        let string_single: TypedOrList<String> = "hello".to_string().into();
        let string_multi: TypedOrList<String> =
            vec!["hello".to_string(), "world".to_string()].into();

        assert_eq!(string_single, TypedOrList::SingleValue("hello".to_string()));
        assert_eq!(
            string_multi,
            TypedOrList::MultiValue(vec!["hello".to_string(), "world".to_string()])
        );

        // Test with i32 type
        let int_single: TypedOrList<i32> = 42.into();
        let int_multi: TypedOrList<i32> = vec![1, 2, 3].into();

        assert_eq!(int_single, TypedOrList::SingleValue(42));
        assert_eq!(int_multi, TypedOrList::MultiValue(vec![1, 2, 3]));

        // Test serialization of different variants
        let single_json = serde_json::to_string(&string_single).unwrap();
        let multi_json = serde_json::to_string(&string_multi).unwrap();

        assert_eq!(single_json, r#""hello""#);
        assert_eq!(multi_json, r#"["hello","world"]"#);
    }

    #[test]
    fn test_array_deserialization() {
        // Test array of values deserializes to MultiValue
        let json = r#"{"wait": [{"name":"0"}, {"name":"1"}]}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(
            obj.wait,
            TypedOrList::MultiValue(vec![json!({"name": "0"}), json!({"name": "1"})])
        );

        // Test single value object deserializes to SingleValue
        let json = r#"{"wait": {"name":"single"}}"#;
        let obj: WaitWrapper = from_str(json).unwrap();
        assert_eq!(
            obj.wait,
            TypedOrList::SingleValue(json!({"name": "single"}))
        );
    }
}
