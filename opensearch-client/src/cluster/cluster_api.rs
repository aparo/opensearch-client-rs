/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */
use bon::bon;

use crate::*;
use reqwest;
use serde::{de::Error as OtherError, Deserialize, Serialize};
use std::sync::Arc;

pub struct ClusterApiClient {
    configuration: Arc<crate::Configuration>,
}

#[bon]
impl ClusterApiClient {
    pub fn new(configuration: Arc<crate::Configuration>) -> Self {
        Self { configuration }
    }

    ///
    /// Returns cluster settings.
    #[builder]
    pub async fn get_settings(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        flat_settings: Option<bool>,
        /// No description available
        human: Option<bool>,
        /// No description available
        include_defaults: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::GetSettingsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cluster/settings", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = flat_settings {
            local_var_req_builder =
                local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_defaults {
            local_var_req_builder =
                local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the decommission status for all zones.
    #[builder]
    pub async fn get_decommission_awareness(
        &self,
        /// No description available
        awareness_attribute_name: String,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::decommission_awareness::DecommissionStatusResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/decommission/awareness/{awareness_attribute_name}/_status",
            local_var_configuration.base_path,
            awareness_attribute_name = awareness_attribute_name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the cluster settings.
    #[builder]
    pub async fn put_settings(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        flat_settings: Option<bool>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The cluster settings to update.
        put_settings: cluster::PutSettings,
    ) -> Result<crate::cluster::PutSettingsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cluster/settings", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = flat_settings {
            local_var_req_builder =
                local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&put_settings);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes a component template.
    #[builder]
    pub async fn delete_component_template(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        name: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_component_template/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about whether a particular component template exist.
    #[builder]
    pub async fn exists_component_template(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        local: Option<bool>,
        /// No description available
        name: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<serde_json::Value, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_component_template/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns one or more component templates.
    #[builder]
    pub async fn get_component_template(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        flat_settings: Option<bool>,
        /// No description available
        human: Option<bool>,
        /// No description available
        local: Option<bool>,
        /// No description available
        name: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::GetComponentTemplateResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_component_template/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = flat_settings {
            local_var_req_builder =
                local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Recommissions a decommissioned zone.
    #[builder]
    pub async fn delete_decommission_awareness(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/decommission/awareness",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Fetches weighted shard routing weights.
    #[builder]
    pub async fn get_weighted_routing(
        &self,
        /// No description available
        attribute: String,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::weighted_routing::WeightsResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/routing/awareness/{attribute}/weights",
            local_var_configuration.base_path,
            attribute = attribute
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Delete weighted shard routing weights.
    #[builder]
    pub async fn delete_weighted_routing(
        &self,
        delete_weighted_routing: cluster::DeleteWeightedRouting,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/routing/awareness/weights",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&delete_weighted_routing);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the cluster voting configuration by excluding certain node IDs or names.
    #[builder]
    pub async fn post_voting_config_exclusions(
        &self,
        /// A comma-separated list of aliases to retrieve. Supports wildcards (`*`).  To retrieve all aliases, omit this parameter or use `*` or `_all`.
        node_names: Option<common::NodeNames>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        node_ids: Option<common::NodeIds>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<serde_json::Value, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/voting_config_exclusions",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = node_ids {
            local_var_req_builder =
                local_var_req_builder.query(&[("node_ids", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = node_names {
            local_var_req_builder =
                local_var_req_builder.query(&[("node_names", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a list of pending cluster-level tasks, such as index creation, mapping updates,
    /// or new allocations.
    #[builder]
    pub async fn pending_tasks(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        local: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::PendingTasksResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/pending_tasks",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Allows to manually change the allocation of individual shards in the cluster.
    #[builder]
    pub async fn reroute(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        dry_run: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        explain: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        metric: Option<common::Metric>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        retry_failed: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The definition of `commands` to perform (`move`, `cancel`, `allocate`)
        reroute: cluster::Reroute,
    ) -> Result<String, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cluster/reroute", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = metric {
            local_var_req_builder =
                local_var_req_builder.query(&[("metric", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = explain {
            local_var_req_builder =
                local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = retry_failed {
            local_var_req_builder =
                local_var_req_builder.query(&[("retry_failed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = dry_run {
            local_var_req_builder =
                local_var_req_builder.query(&[("dry_run", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&reroute);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Explains how shards are allocated in the current cluster and provides an explanation for why unassigned shards can't be allocated to a node.
    #[builder]
    pub async fn allocation_explain(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        include_disk_info: Option<bool>,
        /// No description available
        include_yes_decisions: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The index, shard, and primary flag for which to generate an explanation. Leave this empty to generate an explanation for the first unassigned shard.
        allocation_explain: cluster::AllocationExplain,
    ) -> Result<crate::cluster::AllocationExplainResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/allocation/explain",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = include_disk_info {
            local_var_req_builder =
                local_var_req_builder.query(&[("include_disk_info", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_yes_decisions {
            local_var_req_builder = local_var_req_builder
                .query(&[("include_yes_decisions", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&allocation_explain);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Decommissions a cluster zone based on awareness. This can greatly benefit multi-zone deployments, where awareness attributes can aid in applying new upgrades to a cluster in a controlled fashion.
    #[builder]
    pub async fn put_decommission_awareness(
        &self,
        /// No description available
        awareness_attribute_name: String,
        /// No description available
        awareness_attribute_value: String,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cluster/decommission/awareness/{awareness_attribute_name}/{awareness_attribute_value}", local_var_configuration.base_path, awareness_attribute_name=awareness_attribute_name, awareness_attribute_value=awareness_attribute_value);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns basic information about the health of the cluster.
    #[builder]
    pub async fn health(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// Controls the amount of detail included in the cluster health response.
        level: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        local: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// No description available
        wait_for_no_initializing_shards: Option<bool>,
        /// No description available
        wait_for_no_relocating_shards: Option<bool>,
        /// No description available
        wait_for_nodes: Option<common::WaitForNodes>,
        /// No description available
        wait_for_status: Option<common::WaitForStatus>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
        /// The name of the awareness attribute for which to return the cluster health status (for example, `zone`). Applicable only if `level` is set to `awareness_attributes`.
        awareness_attribute: Option<String>,
        /// Waits until all currently queued events with the given priority are processed.
        wait_for_events: Option<String>,
        /// Waits until the specified number of shards is active before returning a response. Use `all` for all shards.
        wait_for_active_shards: Option<common::wait_for_active_shards::WaitForActiveShards>,
    ) -> Result<crate::cluster::health::HealthResponseBody, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/health/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_no_relocating_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_no_relocating_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_no_initializing_shards {
            local_var_req_builder = local_var_req_builder.query(&[(
                "wait_for_no_initializing_shards",
                &local_var_str.to_string(),
            )]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = level {
            local_var_req_builder =
                local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_nodes {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_nodes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_active_shards {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_active_shards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_events {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_events", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = awareness_attribute {
            local_var_req_builder =
                local_var_req_builder.query(&[("awareness_attribute", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_status {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_status", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns the information about configured remote clusters.
    #[builder]
    pub async fn remote_info(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::RemoteInfoResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_remote/info", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a high-level overview of cluster statistics.
    #[builder]
    pub async fn stats(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        flat_settings: Option<bool>,
        /// No description available
        human: Option<bool>,
        /// No description available
        node_id: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<String, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/stats/nodes/{node_id}",
            local_var_configuration.base_path,
            node_id = node_id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = flat_settings {
            local_var_req_builder =
                local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates weighted shard routing weights.
    #[builder]
    pub async fn put_weighted_routing(
        &self,
        /// No description available
        attribute: String,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
    ) -> Result<crate::cluster::PutWeightedRoutingResponse, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/routing/awareness/{attribute}/weights",
            local_var_configuration.base_path,
            attribute = attribute
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or updates a component template.
    #[builder]
    pub async fn put_component_template(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        timeout: Option<String>,
        /// No description available
        create: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        name: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// The template definition.
        put_component_template: cluster::PutComponentTemplate,
    ) -> Result<crate::common::AcknowledgedResponseBase, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_component_template/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = create {
            local_var_req_builder =
                local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&put_component_template);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Clears any cluster voting configuration exclusions.
    #[builder]
    pub async fn delete_voting_config_exclusions(
        &self,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        human: Option<bool>,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// No description available
        wait_for_removal: Option<bool>,
    ) -> Result<serde_json::Value, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/voting_config_exclusions",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_removal {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_removal", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns comprehensive information about the state of the cluster.
    #[builder]
    pub async fn state(
        &self,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        cluster_manager_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        master_timeout: Option<String>,
        /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
        /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
        wait_for_timeout: Option<String>,
        /// No description available
        allow_no_indices: Option<bool>,
        /// No description available
        error_trace: Option<bool>,
        /// No description available
        filter_path: Option<common::FilterPath>,
        /// No description available
        flat_settings: Option<bool>,
        /// No description available
        human: Option<bool>,
        /// No description available
        ignore_unavailable: Option<bool>,
        /// No description available
        index: String,
        /// No description available
        local: Option<bool>,
        /// No description available
        metric: String,
        /// No description available
        pretty: Option<bool>,
        /// No description available
        source: Option<String>,
        /// No description available
        wait_for_metadata_version: Option<i32>,
        /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
        expand_wildcards: Option<common::ExpandWildcards>,
    ) -> Result<serde_json::Value, Error> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cluster/state/{metric}/{index}",
            local_var_configuration.base_path,
            index = index,
            metric = metric
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = allow_no_indices {
            local_var_req_builder =
                local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = flat_settings {
            local_var_req_builder =
                local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_metadata_version {
            local_var_req_builder = local_var_req_builder
                .query(&[("wait_for_metadata_version", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wait_for_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("wait_for_timeout", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
}
