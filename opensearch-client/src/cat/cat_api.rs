/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */
use bon::bon;

use super::{configuration, Error};
use crate::apis::ContentType;
use crate::*;
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as OtherError, Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait CatApi: Send + Sync {
    /// GET /_cat///
    /// Returns help for the Cat APIs.
    async fn help(&self, params: HelpParams) -> Result<String, Error>;

    /// GET /_cat/pending_tasks///
    /// Returns a concise representation of the cluster's pending tasks.
    async fn pending_tasks(
        &self,
        params: PendingTasksParams,
    ) -> Result<Vec<cat::pending_tasks::PendingTasksRecord>, Error>;

    /// GET /_cat/master///
    /// Returns information about the cluster-manager node.
    async fn master(&self, params: MasterParams) -> Result<String, Error>;

    /// GET /_cat/cluster_manager///
    /// Returns information about the cluster-manager node.
    async fn cluster_manager(
        &self,
        params: ClusterManagerParams,
    ) -> Result<Vec<cat::cluster_manager::ClusterManagerRecord>, Error>;

    /// GET /_cat/thread_pool/{thread_pool_patterns}///
    /// Returns cluster-wide thread pool statistics per node.
    /// By default the active, queued, and rejected statistics are returned for all thread pools.
    async fn thread_pool(
        &self,
        params: ThreadPoolParams,
    ) -> Result<Vec<cat::thread_pool::ThreadPoolRecord>, Error>;

    /// GET /_cat/plugins///
    /// Returns information about the names, components, and versions of the installed plugins.
    async fn plugins(
        &self,
        params: PluginsParams,
    ) -> Result<Vec<cat::plugins::PluginsRecord>, Error>;

    /// GET /_cat/count/{index}///
    /// Provides quick access to the document count of the entire cluster or of an individual index.
    async fn count(
        &self,
        params: CountParams,
    ) -> Result<Vec<cat::count::CountRecord>, Error>;

    /// GET /_cat/health///
    /// Returns a concise representation of the cluster health.
    async fn health(&self, params: HealthParams) -> Result<String, Error>;

    /// GET /_cat/aliases/{name}///
    /// Shows information about aliases currently configured to indexes, including filter and routing information.
    async fn aliases(&self, params: AliasesParams) -> Result<String, Error>;

    /// GET /_cat/shards/{index}///
    /// Lists the states of all primary and replica shards and how they are distributed.
    async fn shards(&self, params: ShardsParams) -> Result<String, Error>;

    /// GET /_cat/tasks///
    /// Lists the progress of all tasks currently running on the cluster.
    async fn tasks(
        &self,
        params: TasksParams,
    ) -> Result<Vec<cat::tasks::TasksRecord>, Error>;

    /// GET /_cat/nodeattrs///
    /// Returns information about custom node attributes.
    async fn nodeattrs(
        &self,
        params: NodeattrsParams,
    ) -> Result<Vec<cat::nodeattrs::NodeAttributesRecord>, Error>;

    /// GET /_cat/templates/{name}///
    /// Lists the names, patterns, order numbers, and version numbers of index templates.
    async fn templates(&self, params: TemplatesParams) -> Result<String, Error>;

    /// GET /_cat/snapshots/{repository}///
    /// Lists all of the snapshots stored in a specific repository.
    async fn snapshots(
        &self,
        params: SnapshotsParams,
    ) -> Result<Vec<cat::snapshots::SnapshotsRecord>, Error>;

    /// GET /_cat/indices/{index}///
    /// Lists information related to indexes, that is, how much disk space they are using, how many shards they have, their health status, and so on.
    async fn indices(&self, params: IndicesParams) -> Result<String, Error>;

    /// GET /_cat/repositories///
    /// Returns information about all snapshot repositories for a cluster.
    async fn repositories(
        &self,
        params: RepositoriesParams,
    ) -> Result<String, Error>;

    /// GET /_cat/segments/{index}///
    /// Provides low-level information about the segments in the shards of an index.
    async fn segments(&self, params: SegmentsParams) -> Result<String, Error>;

    /// GET /_cat/fielddata/{fields}///
    /// Shows how much heap memory is currently being used by field data on every data node in the cluster.
    async fn fielddata(
        &self,
        params: FielddataParams,
    ) -> Result<Vec<cat::fielddata::FielddataRecord>, Error>;

    /// GET /_cat/nodes///
    /// Returns basic statistics about the performance of cluster nodes.
    async fn nodes(
        &self,
        params: NodesParams,
    ) -> Result<Vec<cat::nodes::NodesRecord>, Error>;

    /// GET /_cat/recovery/{index}///
    /// Returns all completed and ongoing index and shard recoveries.
    async fn recovery(
        &self,
        params: RecoveryParams,
    ) -> Result<Vec<cat::recovery::RecoveryRecord>, Error>;

    /// GET /_cat/allocation/{node_id}///
    /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
    async fn allocation(
        &self,
        params: AllocationParams,
    ) -> Result<Vec<cat::allocation::AllocationRecord>, Error>;
}

pub struct CatApiClient {
    configuration: Arc<crate::Configuration>,
}

impl CatApiClient {
    pub fn new(configuration: Arc<crate::Configuration>) -> Self {
        Self { configuration }
    }
}

/// Struct for passing parameters to the method [`help`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct HelpParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`pending_tasks`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PendingTasksParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`master`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct MasterParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`cluster_manager`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ClusterManagerParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the HTTP `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`thread_pool`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ThreadPoolParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub thread_pool_patterns: String,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
    /// The multiplier in which to display values.
    pub size: Option<i32>,
}
/// Struct for passing parameters to the method [`plugins`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PluginsParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`count`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CountParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub index: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
}
/// Struct for passing parameters to the method [`health`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct HealthParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub ts: Option<bool>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`aliases`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct AliasesParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub name: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
    pub expand_wildcards: Option<common::ExpandWildcards>,
    /// Whether to return information from the local node only instead of from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`shards`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ShardsParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub index: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`tasks`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct TasksParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub actions: Option<Vec<String>>,
    /// No description available
    pub detailed: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub nodes: Option<Vec<String>>,
    /// No description available
    pub parent_task_id: Option<String>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`nodeattrs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NodeattrsParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`templates`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct TemplatesParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub name: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`snapshots`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SnapshotsParams {
    /// A comma-separated list of aliases to retrieve. Supports wildcards (`*`).  To retrieve all aliases, omit this parameter or use `*` or `_all`.
    pub repository: common::Repository,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub ignore_unavailable: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`indices`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct IndicesParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub health: Option<common::Health>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub include_unloaded_segments: Option<bool>,
    /// No description available
    pub index: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub pri: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
    /// Specifies the type of index that wildcard expressions can match. Supports comma-separated values.
    pub expand_wildcards: Option<common::ExpandWildcards>,
}
/// Struct for passing parameters to the method [`repositories`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RepositoriesParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
}
/// Struct for passing parameters to the method [`segments`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SegmentsParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub index: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
}
/// Struct for passing parameters to the method [`fielddata`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FielddataParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub fields: common::Fields,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
}
/// Struct for passing parameters to the method [`nodes`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NodesParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Certain APIs may return values, including numbers such as epoch timestamps, as strings. This setting captures
    /// this behavior while keeping the semantics of the field type.
    ///
    /// Depending on the target language, code generators can keep the union or remove it and leniently parse
    /// strings to the target type.
    pub full_id: Option<common::full_id>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from the cluster manager node.
    pub local: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`recovery`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RecoveryParams {
    /// A short version of the `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub active_only: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub detailed: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub index: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Specifies the time units, for example, `5d` or `7h`. For more information, see [Supported units](https://opensearch.org/docs/latest/api-reference/units/).
    pub time: Option<common::Time>,
}
/// Struct for passing parameters to the method [`allocation`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct AllocationParams {
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub cluster_manager_timeout: Option<String>,
    /// A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and
    /// `d` (days). Also accepts "0" without a unit and "-1" to indicate an unspecified value.
    pub master_timeout: Option<String>,
    /// A short version of the HTTP `Accept` header, such as `json` or `yaml`.
    pub format: Option<String>,
    /// Enables verbose mode, which displays column headers.
    pub v: Option<bool>,
    /// No description available
    pub bytes: Option<common::Bytes>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub h: Option<Vec<String>>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub node_id: String,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub s: Option<Vec<String>>,
    /// No description available
    pub source: Option<String>,
    /// Returns help information.
    pub help: Option<bool>,
    /// Returns local information but does not retrieve the state from cluster-manager node.
    pub local: Option<bool>,
}

#[async_trait]
impl CatApi for CatApiClient {
    ///
    /// Returns help for the Cat APIs.
    async fn help(&self, params: HelpParams) -> Result<String, Error> {
        let HelpParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a concise representation of the cluster's pending tasks.
    async fn pending_tasks(
        &self,
        params: PendingTasksParams,
    ) -> Result<Vec<cat::pending_tasks::PendingTasksRecord>, Error> {
        let PendingTasksParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/pending_tasks", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about the cluster-manager node.
    async fn master(&self, params: MasterParams) -> Result<String, Error> {
        let MasterParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/master", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about the cluster-manager node.
    async fn cluster_manager(
        &self,
        params: ClusterManagerParams,
    ) -> Result<Vec<cat::cluster_manager::ClusterManagerRecord>, Error> {
        let ClusterManagerParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str =
            format!("{}_cat/cluster_manager", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns cluster-wide thread pool statistics per node.
    /// By default the active, queued, and rejected statistics are returned for all thread pools.
    async fn thread_pool(
        &self,
        params: ThreadPoolParams,
    ) -> Result<Vec<cat::thread_pool::ThreadPoolRecord>, Error> {
        let ThreadPoolParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            thread_pool_patterns,
            help,
            local,
            size,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/thread_pool/{thread_pool_patterns}",
            local_var_configuration.base_path,
            thread_pool_patterns = thread_pool_patterns
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = size {
            local_var_req_builder =
                local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about the names, components, and versions of the installed plugins.
    async fn plugins(
        &self,
        params: PluginsParams,
    ) -> Result<Vec<cat::plugins::PluginsRecord>, Error> {
        let PluginsParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/plugins", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Provides quick access to the document count of the entire cluster or of an individual index.
    async fn count(
        &self,
        params: CountParams,
    ) -> Result<Vec<cat::count::CountRecord>, Error> {
        let CountParams {
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            index,
            pretty,
            s,
            source,
            help,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/count/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns a concise representation of the cluster health.
    async fn health(&self, params: HealthParams) -> Result<String, Error> {
        let HealthParams {
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            ts,
            help,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/health", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = ts {
            local_var_req_builder =
                local_var_req_builder.query(&[("ts", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Shows information about aliases currently configured to indexes, including filter and routing information.
    async fn aliases(&self, params: AliasesParams) -> Result<String, Error> {
        let AliasesParams {
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            name,
            pretty,
            s,
            source,
            help,
            expand_wildcards,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/aliases/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Lists the states of all primary and replica shards and how they are distributed.
    async fn shards(&self, params: ShardsParams) -> Result<String, Error> {
        let ShardsParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            bytes,
            error_trace,
            filter_path,
            h,
            human,
            index,
            pretty,
            s,
            source,
            help,
            local,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/shards/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Lists the progress of all tasks currently running on the cluster.
    async fn tasks(
        &self,
        params: TasksParams,
    ) -> Result<Vec<cat::tasks::TasksRecord>, Error> {
        let TasksParams {
            format,
            v,
            actions,
            detailed,
            error_trace,
            filter_path,
            h,
            human,
            nodes,
            parent_task_id,
            pretty,
            s,
            source,
            help,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/tasks", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = detailed {
            local_var_req_builder =
                local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = parent_task_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("parent_task_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = nodes {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("nodes".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "nodes",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = actions {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("actions".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "actions",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about custom node attributes.
    async fn nodeattrs(
        &self,
        params: NodeattrsParams,
    ) -> Result<Vec<cat::nodeattrs::NodeAttributesRecord>, Error> {
        let NodeattrsParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/nodeattrs", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Lists the names, patterns, order numbers, and version numbers of index templates.
    async fn templates(&self, params: TemplatesParams) -> Result<String, Error> {
        let TemplatesParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            name,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/templates/{name}",
            local_var_configuration.base_path,
            name = name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Lists all of the snapshots stored in a specific repository.
    async fn snapshots(
        &self,
        params: SnapshotsParams,
    ) -> Result<Vec<cat::snapshots::SnapshotsRecord>, Error> {
        let SnapshotsParams {
            repository,
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            ignore_unavailable,
            pretty,
            s,
            source,
            help,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/snapshots/{repository}",
            local_var_configuration.base_path,
            repository = repository
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        local_var_req_builder =
            local_var_req_builder.query(&[("repository", &repository.to_string())]);
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ignore_unavailable {
            local_var_req_builder =
                local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Lists information related to indexes, that is, how much disk space they are using, how many shards they have, their health status, and so on.
    async fn indices(&self, params: IndicesParams) -> Result<String, Error> {
        let IndicesParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            bytes,
            error_trace,
            filter_path,
            h,
            health,
            human,
            include_unloaded_segments,
            index,
            pretty,
            pri,
            s,
            source,
            help,
            local,
            time,
            expand_wildcards,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/indices/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expand_wildcards {
            local_var_req_builder =
                local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = include_unloaded_segments {
            local_var_req_builder = local_var_req_builder
                .query(&[("include_unloaded_segments", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pri {
            local_var_req_builder =
                local_var_req_builder.query(&[("pri", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = health {
            local_var_req_builder =
                local_var_req_builder.query(&[("health", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns information about all snapshot repositories for a cluster.
    async fn repositories(
        &self,
        params: RepositoriesParams,
    ) -> Result<String, Error> {
        let RepositoriesParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/repositories", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Provides low-level information about the segments in the shards of an index.
    async fn segments(&self, params: SegmentsParams) -> Result<String, Error> {
        let SegmentsParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            bytes,
            error_trace,
            filter_path,
            h,
            human,
            index,
            pretty,
            s,
            source,
            help,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/segments/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Shows how much heap memory is currently being used by field data on every data node in the cluster.
    async fn fielddata(
        &self,
        params: FielddataParams,
    ) -> Result<Vec<cat::fielddata::FielddataRecord>, Error> {
        let FielddataParams {
            format,
            v,
            bytes,
            error_trace,
            fields,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/fielddata/{fields}",
            local_var_configuration.base_path,
            fields = fields
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        local_var_req_builder = local_var_req_builder.query(&[("fields", &fields.to_string())]);
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns basic statistics about the performance of cluster nodes.
    async fn nodes(
        &self,
        params: NodesParams,
    ) -> Result<Vec<cat::nodes::NodesRecord>, Error> {
        let NodesParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            full_id,
            v,
            bytes,
            error_trace,
            filter_path,
            h,
            human,
            pretty,
            s,
            source,
            help,
            local,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_cat/nodes", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = full_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("full_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns all completed and ongoing index and shard recoveries.
    async fn recovery(
        &self,
        params: RecoveryParams,
    ) -> Result<Vec<cat::recovery::RecoveryRecord>, Error> {
        let RecoveryParams {
            format,
            v,
            active_only,
            bytes,
            detailed,
            error_trace,
            filter_path,
            h,
            human,
            index,
            pretty,
            s,
            source,
            help,
            time,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/recovery/{index}",
            local_var_configuration.base_path,
            index = index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = detailed {
            local_var_req_builder =
                local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = time {
            local_var_req_builder =
                local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = active_only {
            local_var_req_builder =
                local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = index {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("index".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "index",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.
    async fn allocation(
        &self,
        params: AllocationParams,
    ) -> Result<Vec<cat::allocation::AllocationRecord>, Error> {
        let AllocationParams {
            cluster_manager_timeout,
            master_timeout,
            format,
            v,
            bytes,
            error_trace,
            filter_path,
            h,
            human,
            node_id,
            pretty,
            s,
            source,
            help,
            local,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_cat/allocation/{node_id}",
            local_var_configuration.base_path,
            node_id = node_id
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = format {
            local_var_req_builder =
                local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = bytes {
            local_var_req_builder =
                local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = local {
            local_var_req_builder =
                local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = master_timeout {
            local_var_req_builder =
                local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = v {
            local_var_req_builder =
                local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cluster_manager_timeout {
            local_var_req_builder = local_var_req_builder
                .query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = h {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("h".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "h",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = help {
            local_var_req_builder =
                local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = s {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("s".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "s",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
}



/// Struct for typed errors of method [`pending_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PendingTasksError {
    DefaultResponse(Vec<cat::pending_tasks::PendingTasksRecord>),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`cluster_manager`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterManagerError {
    DefaultResponse(Vec<cat::cluster_manager::ClusterManagerRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`thread_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ThreadPoolError {
    DefaultResponse(Vec<cat::thread_pool::ThreadPoolRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`plugins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PluginsError {
    DefaultResponse(Vec<cat::plugins::PluginsRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountError {
    DefaultResponse(Vec<cat::count::CountRecord>),
    UnknownValue(serde_json::Value),
}







/// Struct for typed errors of method [`tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TasksError {
    DefaultResponse(Vec<cat::tasks::TasksRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`nodeattrs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodeattrsError {
    DefaultResponse(Vec<cat::nodeattrs::NodeAttributesRecord>),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`snapshots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotsError {
    DefaultResponse(Vec<cat::snapshots::SnapshotsRecord>),
    UnknownValue(serde_json::Value),
}







/// Struct for typed errors of method [`fielddata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FielddataError {
    DefaultResponse(Vec<cat::fielddata::FielddataRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`nodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesError {
    DefaultResponse(Vec<cat::nodes::NodesRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`recovery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecoveryError {
    DefaultResponse(Vec<cat::recovery::RecoveryRecord>),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`allocation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AllocationError {
    DefaultResponse(Vec<cat::allocation::AllocationRecord>),
    UnknownValue(serde_json::Value),
}
