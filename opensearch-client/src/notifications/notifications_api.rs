/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */
use bon::bon;

use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize, de::Error as OtherError};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};
use crate::apis::ContentType;
use crate::*;


#[async_trait]
pub trait NotificationsApi: Send + Sync {


    /// DELETE /_plugins/_notifications/configs/{config_id}///
    /// Delete a channel configuration.
    async fn delete_config(&self, params: DeleteConfigParams) -> Result<crate::notifications::DeleteConfigsResponse, Error>;

    /// GET /_plugins/_notifications/features///
    /// List supported channel configurations.
    async fn list_features(&self, params: ListFeaturesParams) -> Result<crate::notifications::ListFeaturesResponse, Error>;

    /// POST /_plugins/_notifications/feature/test/{config_id}///
    /// Send a test notification.
    async fn send_test(&self, params: SendTestParams) -> Result<crate::notifications::SendTestResponse, Error>;

    /// GET /_plugins/_notifications/configs///
    /// Get multiple channel configurations with filtering.
    async fn get_configs(&self, params: GetConfigsParams) -> Result<crate::notifications::GetConfigsResponse, Error>;

    /// PUT /_plugins/_notifications/configs/{config_id}///
    /// Update channel configuration.
    async fn update_config(&self, params: UpdateConfigParams) -> Result<crate::notifications::UpdateConfigResponse, Error>;

    /// POST /_plugins/_notifications/configs///
    /// Create channel configuration.
    async fn create_config(&self, params: CreateConfigParams) -> Result<crate::notifications::CreateConfigResponse, Error>;

    /// GET /_plugins/_notifications/configs/{config_id}///
    /// Get a specific channel configuration.
    async fn get_config(&self, params: GetConfigParams) -> Result<crate::notifications::GetConfigsResponse, Error>;

    /// GET /_plugins/_notifications/channels///
    /// List created notification channels.
    async fn list_channels(&self, params: ListChannelsParams) -> Result<crate::notifications::ListChannelsResponse, Error>;
}

pub struct NotificationsApiClient {
    configuration: Arc<crate::Configuration>
}

impl NotificationsApiClient {
    pub fn new(configuration: Arc<crate::Configuration>) -> Self {
        Self { configuration }
    }
}


/// Struct for passing parameters to the method [`delete_config`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteConfigParams {
      /// No description available
    pub config_id: String,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`list_features`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ListFeaturesParams {
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`send_test`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SendTestParams {
      /// No description available
    pub config_id: String,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_configs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetConfigsParams {
    
    pub get_configs: notifications::GetConfigs,
      /// No description available
    pub chime_url: Option<String>,
      /// No description available
    pub chime_url_keyword: Option<String>,
      /// No description available
    pub config_id: Option<String>,
      /// No description available
    pub config_id_list: Option<Vec<String>>,
      /// No description available
    pub created_time_ms: Option<i32>,
      /// No description available
    pub description: Option<String>,
      /// No description available
    pub description_keyword: Option<String>,
      /// No description available
    pub email_email_account_id: Option<String>,
      /// No description available
    pub email_email_group_id_list: Option<String>,
      /// No description available
    pub email_recipient_list_recipient: Option<String>,
      /// No description available
    pub email_recipient_list_recipient_keyword: Option<String>,
      /// No description available
    pub email_group_recipient_list_recipient: Option<String>,
      /// No description available
    pub email_group_recipient_list_recipient_keyword: Option<String>,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub is_enabled: Option<bool>,
      /// No description available
    pub last_updated_time_ms: Option<i32>,
      /// No description available
    pub microsoft_teams_url: Option<String>,
      /// No description available
    pub microsoft_teams_url_keyword: Option<String>,
      /// No description available
    pub name: Option<String>,
      /// No description available
    pub name_keyword: Option<String>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub query: Option<String>,
      /// No description available
    pub ses_account_from_address: Option<String>,
      /// No description available
    pub ses_account_from_address_keyword: Option<String>,
      /// No description available
    pub ses_account_region: Option<String>,
      /// No description available
    pub ses_account_role_arn: Option<String>,
      /// No description available
    pub ses_account_role_arn_keyword: Option<String>,
      /// No description available
    pub slack_url: Option<String>,
      /// No description available
    pub slack_url_keyword: Option<String>,
      /// No description available
    pub smtp_account_from_address: Option<String>,
      /// No description available
    pub smtp_account_from_address_keyword: Option<String>,
      /// No description available
    pub smtp_account_host: Option<String>,
      /// No description available
    pub smtp_account_host_keyword: Option<String>,
      /// No description available
    pub smtp_account_method: Option<String>,
      /// No description available
    pub sns_role_arn: Option<String>,
      /// No description available
    pub sns_role_arn_keyword: Option<String>,
      /// No description available
    pub sns_topic_arn: Option<String>,
      /// No description available
    pub sns_topic_arn_keyword: Option<String>,
      /// No description available
    pub source: Option<String>,
      /// No description available
    pub text_query: Option<String>,
      /// No description available
    pub webhook_url: Option<String>,
      /// No description available
    pub webhook_url_keyword: Option<String>,
      /// Type of notification configuration.
    pub config_type: Option<String>,
}
/// Struct for passing parameters to the method [`update_config`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateConfigParams {
    
    pub update_config: notifications::UpdateConfig,
      /// No description available
    pub config_id: String,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_config`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateConfigParams {
    
    pub create_config: notifications::CreateConfig,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_config`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetConfigParams {
      /// No description available
    pub config_id: String,
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`list_channels`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ListChannelsParams {
      /// No description available
    pub error_trace: Option<bool>,
      /// No description available
    pub filter_path: Option<common::FilterPath>,
      /// No description available
    pub human: Option<bool>,
      /// No description available
    pub pretty: Option<bool>,
      /// No description available
    pub source: Option<String>,
}

#[async_trait]
impl NotificationsApi for NotificationsApiClient {
///
      /// Delete a channel configuration.
    async fn delete_config(&self, params: DeleteConfigParams) -> Result<crate::notifications::DeleteConfigsResponse, Error> {
        let DeleteConfigParams {
            config_id,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/configs/{config_id}", local_var_configuration.base_path, config_id=config_id);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }







        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// List supported channel configurations.
    async fn list_features(&self, params: ListFeaturesParams) -> Result<crate::notifications::ListFeaturesResponse, Error> {
        let ListFeaturesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/features", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }







        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// Send a test notification.
    async fn send_test(&self, params: SendTestParams) -> Result<crate::notifications::SendTestResponse, Error> {
        let SendTestParams {
            config_id,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/feature/test/{config_id}", local_var_configuration.base_path, config_id=config_id);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }







        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// Get multiple channel configurations with filtering.
    async fn get_configs(&self, params: GetConfigsParams) -> Result<crate::notifications::GetConfigsResponse, Error> {
        let GetConfigsParams {
            get_configs,
            chime_url,
            chime_url_keyword,
            config_id,
            config_id_list,
            created_time_ms,
            description,
            description_keyword,
            email_email_account_id,
            email_email_group_id_list,
            email_recipient_list_recipient,
            email_recipient_list_recipient_keyword,
            email_group_recipient_list_recipient,
            email_group_recipient_list_recipient_keyword,
            error_trace,
            filter_path,
            human,
            is_enabled,
            last_updated_time_ms,
            microsoft_teams_url,
            microsoft_teams_url_keyword,
            name,
            name_keyword,
            pretty,
            query,
            ses_account_from_address,
            ses_account_from_address_keyword,
            ses_account_region,
            ses_account_role_arn,
            ses_account_role_arn_keyword,
            slack_url,
            slack_url_keyword,
            smtp_account_from_address,
            smtp_account_from_address_keyword,
            smtp_account_host,
            smtp_account_host_keyword,
            smtp_account_method,
            sns_role_arn,
            sns_role_arn_keyword,
            sns_topic_arn,
            sns_topic_arn_keyword,
            source,
            text_query,
            webhook_url,
            webhook_url_keyword,
            config_type,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/configs", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = sns.topic_arn.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("sns.topic_arn.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email.recipient_list.recipient.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("email.recipient_list.recipient.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slack.url.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("slack.url.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = microsoft_teams.url {
        local_var_req_builder = local_var_req_builder.query(&[("microsoft_teams.url", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chime.url {
        local_var_req_builder = local_var_req_builder.query(&[("chime.url", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_time_ms {
        local_var_req_builder = local_var_req_builder.query(&[("created_time_ms", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ses_account.role_arn {
        local_var_req_builder = local_var_req_builder.query(&[("ses_account.role_arn", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ses_account.role_arn.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("ses_account.role_arn.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("is_enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = smtp_account.from_address.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("smtp_account.from_address.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sns.topic_arn {
        local_var_req_builder = local_var_req_builder.query(&[("sns.topic_arn", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email.email_account_id {
        local_var_req_builder = local_var_req_builder.query(&[("email.email_account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email_group.recipient_list.recipient.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("email_group.recipient_list.recipient.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = microsoft_teams.url.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("microsoft_teams.url.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slack.url {
        local_var_req_builder = local_var_req_builder.query(&[("slack.url", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = smtp_account.from_address {
        local_var_req_builder = local_var_req_builder.query(&[("smtp_account.from_address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ses_account.from_address.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("ses_account.from_address.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = webhook.url.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("webhook.url.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = smtp_account.host.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("smtp_account.host.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email_group.recipient_list.recipient {
        local_var_req_builder = local_var_req_builder.query(&[("email_group.recipient_list.recipient", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = text_query {
        local_var_req_builder = local_var_req_builder.query(&[("text_query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email.email_group_id_list {
        local_var_req_builder = local_var_req_builder.query(&[("email.email_group_id_list", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = config_id {
        local_var_req_builder = local_var_req_builder.query(&[("config_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email.recipient_list.recipient {
        local_var_req_builder = local_var_req_builder.query(&[("email.recipient_list.recipient", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = description.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("description.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = config_type {
        local_var_req_builder = local_var_req_builder.query(&[("config_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("name.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ses_account.from_address {
        local_var_req_builder = local_var_req_builder.query(&[("ses_account.from_address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = smtp_account.host {
        local_var_req_builder = local_var_req_builder.query(&[("smtp_account.host", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_updated_time_ms {
        local_var_req_builder = local_var_req_builder.query(&[("last_updated_time_ms", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = chime.url.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("chime.url.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ses_account.region {
        local_var_req_builder = local_var_req_builder.query(&[("ses_account.region", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = webhook.url {
        local_var_req_builder = local_var_req_builder.query(&[("webhook.url", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = config_id_list {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("config_id_list".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("config_id_list", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sns.role_arn {
        local_var_req_builder = local_var_req_builder.query(&[("sns.role_arn", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = smtp_account.method {
        local_var_req_builder = local_var_req_builder.query(&[("smtp_account.method", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sns.role_arn.keyword {
        local_var_req_builder = local_var_req_builder.query(&[("sns.role_arn.keyword", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = description {
        local_var_req_builder = local_var_req_builder.query(&[("description", &local_var_str.to_string())]);
    }






    local_var_req_builder = local_var_req_builder.json(&get_configs);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// Update channel configuration.
    async fn update_config(&self, params: UpdateConfigParams) -> Result<crate::notifications::UpdateConfigResponse, Error> {
        let UpdateConfigParams {
            update_config,
            config_id,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/configs/{config_id}", local_var_configuration.base_path, config_id=config_id);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }






    local_var_req_builder = local_var_req_builder.json(&update_config);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// Create channel configuration.
    async fn create_config(&self, params: CreateConfigParams) -> Result<crate::notifications::CreateConfigResponse, Error> {
        let CreateConfigParams {
            create_config,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/configs", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }






    local_var_req_builder = local_var_req_builder.json(&create_config);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// Get a specific channel configuration.
    async fn get_config(&self, params: GetConfigParams) -> Result<crate::notifications::GetConfigsResponse, Error> {
        let GetConfigParams {
            config_id,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/configs/{config_id}", local_var_configuration.base_path, config_id=config_id);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }







        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }///
      /// List created notification channels.
    async fn list_channels(&self, params: ListChannelsParams) -> Result<crate::notifications::ListChannelsResponse, Error> {
        let ListChannelsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;
    
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}_plugins/_notifications/channels", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());


    if let Some(ref local_var_str) = pretty {
        local_var_req_builder = local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source {
        local_var_req_builder = local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filter_path {
        local_var_req_builder = local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = error_trace {
        local_var_req_builder = local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = human {
        local_var_req_builder = local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
    }







        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            
            serde_json::from_str(&local_var_content).map_err(Error::from)
            
            
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
}




















