/*
 * opensearch-client
 *
 * Rust Client for OpenSearch
 *
 * The version of the OpenAPI document: 3.1.0
 * Contact: alberto.paro@gmail.com
 * Generated by Paro OpenAPI Generator
 */
use bon::bon;

use super::{configuration, Error};
use crate::apis::ContentType;
use crate::*;
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as OtherError, Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait SecurityApi: Send + Sync {
    /// GET /_plugins/_security/dashboardsinfo///
    /// Retrieves the current values for dynamic security settings for OpenSearch Dashboards.
    async fn get_dashboards_info(
        &self,
        params: GetDashboardsInfoParams,
    ) -> Result<GetDashboardsInfoSuccess, Error>;

    /// PATCH /_plugins/_security/api/nodesdn/{cluster_name}///
    /// Updates the distinguished cluster name for the specified cluster. Requires super admin or REST API permissions.
    async fn patch_distinguished_name(
        &self,
        params: PatchDistinguishedNameParams,
    ) -> Result<PatchDistinguishedNameSuccess, Error>;

    /// PUT /_plugins/_security/api/nodesdn/{cluster_name}///
    /// Adds or updates the specified distinguished names in the cluster or node allowlist. Requires super admin or REST API permissions.
    async fn update_distinguished_name(
        &self,
        params: UpdateDistinguishedNameParams,
    ) -> Result<UpdateDistinguishedNameSuccess, Error>;

    /// POST /_plugins/_security/authinfo///
    /// Returns or updates authentication information for the currently authenticated user.
    async fn authinfo(
        &self,
        params: AuthinfoParams,
    ) -> Result<AuthinfoSuccess, Error>;

    /// PATCH /_plugins/_security/api/tenants/{tenant}///
    /// Adds, deletes, or modifies a single tenant.
    async fn patch_tenant(
        &self,
        params: PatchTenantParams,
    ) -> Result<PatchTenantSuccess, Error>;

    /// GET /_plugins/_security/api/actiongroups/{action_group}///
    /// Retrieves one action group.
    async fn get_action_group(
        &self,
        params: GetActionGroupParams,
    ) -> Result<crate::security::ActionGroupsMap, Error>;

    /// GET /_plugins/_security/api/account///
    /// Returns account information for the current user.
    async fn get_account_details(
        &self,
        params: GetAccountDetailsParams,
    ) -> Result<crate::security::AccountDetails, Error>;

    /// POST /_plugins/_security/dashboardsinfo///
    /// Retrieves the current values for dynamic security settings for OpenSearch Dashboards.
    async fn post_dashboards_info(
        &self,
        params: PostDashboardsInfoParams,
    ) -> Result<PostDashboardsInfoSuccess, Error>;

    /// PATCH /_plugins/_security/api/audit///
    /// Updates the specified fields in the audit configuration.
    async fn patch_audit_configuration(
        &self,
        params: PatchAuditConfigurationParams,
    ) -> Result<crate::security::Ok, Error>;

    /// PATCH /_plugins/_security/api/rolesmapping/{role}///
    /// Updates the individual attributes of a role mapping.
    async fn patch_role_mapping(
        &self,
        params: PatchRoleMappingParams,
    ) -> Result<PatchRoleMappingSuccess, Error>;

    /// PUT /_plugins/_security/api/rolesmapping/{role}///
    /// Creates or replaces the specified role mapping.
    async fn create_role_mapping(
        &self,
        params: CreateRoleMappingParams,
    ) -> Result<CreateRoleMappingSuccess, Error>;

    /// GET /_plugins/_security/api/rolesmapping/{role}///
    /// Retrieves the specified role mapping.
    async fn get_role_mapping(
        &self,
        params: GetRoleMappingParams,
    ) -> Result<crate::security::RoleMappings, Error>;

    /// GET /_plugins/_security/api/rolesmapping///
    /// Retrieves all role mappings.
    async fn get_role_mappings(
        &self,
        params: GetRoleMappingsParams,
    ) -> Result<crate::security::RoleMappings, Error>;

    /// PATCH /_plugins/_security/api/actiongroups/{action_group}///
    /// Updates the individual attributes of an action group.
    async fn patch_action_group(
        &self,
        params: PatchActionGroupParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/nodesdn/{cluster_name}///
    /// Retrieves all node distinguished names. Requires super admin or REST API permissions.
    async fn get_distinguished_name(
        &self,
        params: GetDistinguishedNameParams,
    ) -> Result<GetDistinguishedNameSuccess, Error>;

    /// GET /_plugins/_security/api/internalusers///
    /// Retrieve all internal users.
    async fn get_users(
        &self,
        params: GetUsersParams,
    ) -> Result<crate::security::UsersMap, Error>;

    /// PATCH /_plugins/_security/api/rolesmapping///
    /// Creates or updates multiple role mappings in a single request.
    async fn patch_role_mappings(
        &self,
        params: PatchRoleMappingsParams,
    ) -> Result<PatchRoleMappingsSuccess, Error>;

    /// PUT /_plugins/_security/api/internalusers/{username}///
    /// Creates or replaces the specified user.
    async fn create_user(
        &self,
        params: CreateUserParams,
    ) -> Result<CreateUserSuccess, Error>;

    /// POST /_plugins/_security/api/migrate///
    /// Migrates the security configuration from v6 to v7.
    async fn migrate(
        &self,
        params: MigrateParams,
    ) -> Result<MigrateSuccess, Error>;

    /// DELETE /_plugins/_security/api/user/{username}///
    /// Delete the specified user. Legacy API.
    async fn delete_user_legacy(
        &self,
        params: DeleteUserLegacyParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/actiongroups///
    /// Retrieves all action groups.
    async fn get_action_groups(
        &self,
        params: GetActionGroupsParams,
    ) -> Result<crate::security::ActionGroupsMap, Error>;

    /// PATCH /_plugins/_security/api/internalusers///
    /// Creates, updates, or deletes multiple internal users in a single request.
    async fn patch_users(
        &self,
        params: PatchUsersParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/user/{username}///
    /// Retrieve one user. Legacy API.
    async fn get_user_legacy(
        &self,
        params: GetUserLegacyParams,
    ) -> Result<crate::security::UsersMap, Error>;

    /// DELETE /_plugins/_security/api/rolesmapping/{role}///
    /// Deletes the specified role mapping.
    async fn delete_role_mapping(
        &self,
        params: DeleteRoleMappingParams,
    ) -> Result<crate::security::Ok, Error>;

    /// DELETE /_plugins/_security/api/actiongroups/{action_group}///
    /// Deletes the specified action group.
    async fn delete_action_group(
        &self,
        params: DeleteActionGroupParams,
    ) -> Result<crate::security::Ok, Error>;

    /// PATCH /_plugins/_security/api/roles///
    /// Creates, updates, or deletes multiple roles in a single call.
    async fn patch_roles(
        &self,
        params: PatchRolesParams,
    ) -> Result<PatchRolesSuccess, Error>;

    /// GET /_plugins/_security/api/audit///
    /// Retrieves the audit configuration.
    async fn get_audit_configuration(
        &self,
        params: GetAuditConfigurationParams,
    ) -> Result<crate::security::AuditConfigWithReadOnly, Error>;

    /// DELETE /_plugins/_security/api/tenants/{tenant}///
    /// Deletes the specified tenant.
    async fn delete_tenant(
        &self,
        params: DeleteTenantParams,
    ) -> Result<DeleteTenantSuccess, Error>;

    /// POST /_plugins/_security/tenantinfo///
    /// Retrieves the names of current tenants. Requires super admin or `kibanaserver` permissions.
    async fn tenant_info(
        &self,
        params: TenantInfoParams,
    ) -> Result<TenantInfoSuccess, Error>;

    /// DELETE /_plugins/_security/api/roles/{role}///
    /// Deletes the specified role.
    async fn delete_role(
        &self,
        params: DeleteRoleParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/ssl/certs///
    /// Retrieves the cluster security certificates.
    async fn get_certificates(
        &self,
        params: GetCertificatesParams,
    ) -> Result<GetCertificatesSuccess, Error>;

    /// PUT /_plugins/_security/api/tenants/{tenant}///
    /// Creates or replaces the specified tenant.
    async fn create_tenant(
        &self,
        params: CreateTenantParams,
    ) -> Result<CreateTenantSuccess, Error>;

    /// GET /_plugins/_security/api/validate///
    /// Checks whether the v6 security configuration is valid and ready to be migrated to v7.
    async fn validate(
        &self,
        params: ValidateParams,
    ) -> Result<ValidateSuccess, Error>;

    /// GET /_plugins/_security/api/permissionsinfo///
    /// Retrieves the evaluated REST API permissions for the currently logged in user.
    async fn get_permissions_info(
        &self,
        params: GetPermissionsInfoParams,
    ) -> Result<GetPermissionsInfoSuccess, Error>;

    /// DELETE /_plugins/_security/api/nodesdn/{cluster_name}///
    /// Deletes all distinguished names in the specified cluster or node allowlist. Requires super admin or REST API permissions.
    async fn delete_distinguished_name(
        &self,
        params: DeleteDistinguishedNameParams,
    ) -> Result<DeleteDistinguishedNameSuccess, Error>;

    /// POST /_plugins/_security/whoami///
    /// Gets the identity information for the user currently logged in.
    async fn who_am_i(
        &self,
        params: WhoAmIParams,
    ) -> Result<WhoAmISuccess, Error>;

    /// PATCH /_plugins/_security/api/nodesdn///
    /// Bulk updates specified node distinguished names. Requires super admin or REST API permissions.
    async fn patch_distinguished_names(
        &self,
        params: PatchDistinguishedNamesParams,
    ) -> Result<PatchDistinguishedNamesSuccess, Error>;

    /// GET /_plugins/_security/api/tenants/{tenant}///
    /// Retrieves the specified tenant.
    async fn get_tenant(
        &self,
        params: GetTenantParams,
    ) -> Result<crate::security::TenantsMap, Error>;

    /// PUT /_plugins/_security/api/roles/{role}///
    /// Creates or replaces the specified role.
    async fn create_role(
        &self,
        params: CreateRoleParams,
    ) -> Result<CreateRoleSuccess, Error>;

    /// DELETE /_plugins/_security/api/internalusers/{username}///
    /// Deletes the specified internal user.
    async fn delete_user(
        &self,
        params: DeleteUserParams,
    ) -> Result<crate::security::Ok, Error>;

    /// PATCH /_plugins/_security/api/actiongroups///
    /// Creates, updates, or deletes multiple action groups in a single request.
    async fn patch_action_groups(
        &self,
        params: PatchActionGroupsParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/internalusers/{username}///
    /// Retrieve information about the specified internal user.
    async fn get_user(
        &self,
        params: GetUserParams,
    ) -> Result<crate::security::UsersMap, Error>;

    /// GET /_plugins/_security/api/roles///
    /// Retrieves all roles.
    async fn get_roles(
        &self,
        params: GetRolesParams,
    ) -> Result<crate::security::RolesMap, Error>;

    /// DELETE /_plugins/_security/api/cache///
    /// Flushes the Security plugin's user, authentication, and authorization cache.
    async fn flush_cache(
        &self,
        params: FlushCacheParams,
    ) -> Result<crate::security::Ok, Error>;

    /// PUT /_plugins/_security/api/user/{username}///
    /// Creates or replaces the specified user. Legacy API.
    async fn create_user_legacy(
        &self,
        params: CreateUserLegacyParams,
    ) -> Result<CreateUserLegacySuccess, Error>;

    /// PATCH /_plugins/_security/api/tenants///
    /// Adds, deletes, or modifies multiple tenants in a single request.
    async fn patch_tenants(
        &self,
        params: PatchTenantsParams,
    ) -> Result<PatchTenantsSuccess, Error>;

    /// PATCH /_plugins/_security/api/roles/{role}///
    /// Updates the individual attributes of a role.
    async fn patch_role(
        &self,
        params: PatchRoleParams,
    ) -> Result<PatchRoleSuccess, Error>;

    /// GET /_plugins/_security/api/roles/{role}///
    /// Retrieves one role.
    async fn get_role(
        &self,
        params: GetRoleParams,
    ) -> Result<crate::security::RolesMap, Error>;

    /// GET /_plugins/_security/api/nodesdn///
    /// Retrieves all node distinguished names. Requires super admin or REST API permissions.
    async fn get_distinguished_names(
        &self,
        params: GetDistinguishedNamesParams,
    ) -> Result<GetDistinguishedNamesSuccess, Error>;

    /// PUT /_plugins/_security/api/cache///
    /// Not supported for the Cache API.
    async fn cache(
        &self,
        params: CacheParams,
    ) -> Result<crate::security::Error, Error>;

    /// PUT /_plugins/_security/api/actiongroups/{action_group}///
    /// Creates or replaces the specified action group.
    async fn create_action_group(
        &self,
        params: CreateActionGroupParams,
    ) -> Result<CreateActionGroupSuccess, Error>;

    /// POST /_plugins/_security/api/authtoken///
    /// Returns the authorization token for the current user.
    async fn authtoken(
        &self,
        params: AuthtokenParams,
    ) -> Result<crate::security::Ok, Error>;

    /// PUT /_plugins/_security/api/audit/config///
    /// Updates the audit configuration.
    async fn update_audit_configuration(
        &self,
        params: UpdateAuditConfigurationParams,
    ) -> Result<crate::security::Ok, Error>;

    /// POST /_plugins/_security/health///
    /// Checks to see if the Security plugin is running.
    async fn health(
        &self,
        params: HealthParams,
    ) -> Result<crate::security::HealthInfo, Error>;

    /// GET /_plugins/_security/api/user///
    /// Retrieve all internal users. Legacy API.
    async fn get_users_legacy(
        &self,
        params: GetUsersLegacyParams,
    ) -> Result<crate::security::UsersMap, Error>;

    /// PATCH /_plugins/_security/api/internalusers/{username}///
    /// Updates individual attributes for an internal user.
    async fn patch_user(
        &self,
        params: PatchUserParams,
    ) -> Result<crate::security::Ok, Error>;

    /// GET /_plugins/_security/api/tenants///
    /// Retrieves all tenants.
    async fn get_tenants(
        &self,
        params: GetTenantsParams,
    ) -> Result<GetTenantsSuccess, Error>;

    /// PUT /_plugins/_security/api/account///
    /// Changes the password for the current user.
    async fn change_password(
        &self,
        params: ChangePasswordParams,
    ) -> Result<ChangePasswordSuccess, Error>;
}

pub struct SecurityApiClient {
    configuration: Arc<crate::Configuration>,
}

impl SecurityApiClient {
    pub fn new(configuration: Arc<crate::Configuration>) -> Self {
        Self { configuration }
    }
}

/// Struct for passing parameters to the method [`get_dashboards_info`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetDashboardsInfoParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_distinguished_name`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchDistinguishedNameParams {
    /// No description available
    pub cluster_name: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`update_distinguished_name`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateDistinguishedNameParams {
    pub update_distinguished_name: security::UpdateDistinguishedName,
    /// No description available
    pub cluster_name: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`authinfo`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct AuthinfoParams {
    /// No description available
    pub auth_type: Option<String>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub verbose: Option<bool>,
}
/// Struct for passing parameters to the method [`patch_tenant`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchTenantParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub tenant: String,
}
/// Struct for passing parameters to the method [`get_action_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetActionGroupParams {
    /// No description available
    pub action_group: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_account_details`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetAccountDetailsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`post_dashboards_info`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PostDashboardsInfoParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_audit_configuration`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchAuditConfigurationParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_role_mapping`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchRoleMappingParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_role_mapping`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateRoleMappingParams {
    pub create_role_mapping: security::CreateRoleMapping,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_role_mapping`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetRoleMappingParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_role_mappings`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetRoleMappingsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_action_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchActionGroupParams {
    /// No description available
    pub action_group: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_distinguished_name`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetDistinguishedNameParams {
    /// No description available
    pub cluster_name: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub show_all: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_users`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUsersParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_role_mappings`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchRoleMappingsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_user`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateUserParams {
    pub create_user: security::CreateUser,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`migrate`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct MigrateParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_user_legacy`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteUserLegacyParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`get_action_groups`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetActionGroupsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_users`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchUsersParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_user_legacy`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUserLegacyParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`delete_role_mapping`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteRoleMappingParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_action_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteActionGroupParams {
    /// No description available
    pub action_group: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_roles`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchRolesParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_audit_configuration`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetAuditConfigurationParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_tenant`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteTenantParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub tenant: String,
}
/// Struct for passing parameters to the method [`tenant_info`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct TenantInfoParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_role`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteRoleParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_certificates`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetCertificatesParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_tenant`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateTenantParams {
    pub create_tenant: security::CreateTenant,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub tenant: String,
}
/// Struct for passing parameters to the method [`validate`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ValidateParams {
    /// No description available
    pub accept_invalid: Option<bool>,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_permissions_info`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPermissionsInfoParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_distinguished_name`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteDistinguishedNameParams {
    /// No description available
    pub cluster_name: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`who_am_i`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct WhoAmIParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_distinguished_names`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchDistinguishedNamesParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_tenant`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetTenantParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub tenant: String,
}
/// Struct for passing parameters to the method [`create_role`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateRoleParams {
    pub create_role: security::CreateRole,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`delete_user`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteUserParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`patch_action_groups`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchActionGroupsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_user`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUserParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`get_roles`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetRolesParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`flush_cache`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FlushCacheParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_user_legacy`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateUserLegacyParams {
    pub create_user_legacy: security::CreateUserLegacy,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`patch_tenants`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchTenantsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_role`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchRoleParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_role`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetRoleParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub role: String,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_distinguished_names`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetDistinguishedNamesParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub show_all: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`cache`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CacheParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`create_action_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateActionGroupParams {
    pub create_action_group: security::CreateActionGroup,
    /// No description available
    pub action_group: String,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`authtoken`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct AuthtokenParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`update_audit_configuration`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateAuditConfigurationParams {
    pub update_audit_configuration: security::UpdateAuditConfiguration,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`health`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct HealthParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub mode: Option<String>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`get_users_legacy`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUsersLegacyParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`patch_user`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct PatchUserParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
    /// No description available
    pub username: String,
}
/// Struct for passing parameters to the method [`get_tenants`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetTenantsParams {
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}
/// Struct for passing parameters to the method [`change_password`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ChangePasswordParams {
    pub change_password: security::ChangePassword,
    /// No description available
    pub error_trace: Option<bool>,
    /// No description available
    pub filter_path: Option<common::FilterPath>,
    /// No description available
    pub human: Option<bool>,
    /// No description available
    pub pretty: Option<bool>,
    /// No description available
    pub source: Option<String>,
}

#[async_trait]
impl SecurityApi for SecurityApiClient {
    ///
    /// Retrieves the current values for dynamic security settings for OpenSearch Dashboards.
    async fn get_dashboards_info(
        &self,
        params: GetDashboardsInfoParams,
    ) -> Result<GetDashboardsInfoSuccess, Error> {
        let GetDashboardsInfoParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/dashboardsinfo",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetDashboardsInfoSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the distinguished cluster name for the specified cluster. Requires super admin or REST API permissions.
    async fn patch_distinguished_name(
        &self,
        params: PatchDistinguishedNameParams,
    ) -> Result<PatchDistinguishedNameSuccess, Error>
    {
        let PatchDistinguishedNameParams {
            cluster_name,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn/{cluster_name}",
            local_var_configuration.base_path,
            cluster_name = cluster_name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchDistinguishedNameSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Adds or updates the specified distinguished names in the cluster or node allowlist. Requires super admin or REST API permissions.
    async fn update_distinguished_name(
        &self,
        params: UpdateDistinguishedNameParams,
    ) -> Result<UpdateDistinguishedNameSuccess, Error>
    {
        let UpdateDistinguishedNameParams {
            update_distinguished_name,
            cluster_name,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn/{cluster_name}",
            local_var_configuration.base_path,
            cluster_name = cluster_name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&update_distinguished_name);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<UpdateDistinguishedNameSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns or updates authentication information for the currently authenticated user.
    async fn authinfo(
        &self,
        params: AuthinfoParams,
    ) -> Result<AuthinfoSuccess, Error> {
        let AuthinfoParams {
            auth_type,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            verbose,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/authinfo",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = verbose {
            local_var_req_builder =
                local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = auth_type {
            local_var_req_builder =
                local_var_req_builder.query(&[("auth_type", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<AuthinfoSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Adds, deletes, or modifies a single tenant.
    async fn patch_tenant(
        &self,
        params: PatchTenantParams,
    ) -> Result<PatchTenantSuccess, Error> {
        let PatchTenantParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            tenant,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants/{tenant}",
            local_var_configuration.base_path,
            tenant = tenant
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchTenantSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves one action group.
    async fn get_action_group(
        &self,
        params: GetActionGroupParams,
    ) -> Result<crate::security::ActionGroupsMap, Error> {
        let GetActionGroupParams {
            action_group,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups/{action_group}",
            local_var_configuration.base_path,
            action_group = action_group
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns account information for the current user.
    async fn get_account_details(
        &self,
        params: GetAccountDetailsParams,
    ) -> Result<crate::security::AccountDetails, Error> {
        let GetAccountDetailsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/account",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the current values for dynamic security settings for OpenSearch Dashboards.
    async fn post_dashboards_info(
        &self,
        params: PostDashboardsInfoParams,
    ) -> Result<PostDashboardsInfoSuccess, Error> {
        let PostDashboardsInfoParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/dashboardsinfo",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PostDashboardsInfoSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the specified fields in the audit configuration.
    async fn patch_audit_configuration(
        &self,
        params: PatchAuditConfigurationParams,
    ) -> Result<crate::security::Ok, Error> {
        let PatchAuditConfigurationParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/audit",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the individual attributes of a role mapping.
    async fn patch_role_mapping(
        &self,
        params: PatchRoleMappingParams,
    ) -> Result<PatchRoleMappingSuccess, Error> {
        let PatchRoleMappingParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchRoleMappingSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified role mapping.
    async fn create_role_mapping(
        &self,
        params: CreateRoleMappingParams,
    ) -> Result<CreateRoleMappingSuccess, Error> {
        let CreateRoleMappingParams {
            create_role_mapping,
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_role_mapping);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateRoleMappingSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the specified role mapping.
    async fn get_role_mapping(
        &self,
        params: GetRoleMappingParams,
    ) -> Result<crate::security::RoleMappings, Error> {
        let GetRoleMappingParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all role mappings.
    async fn get_role_mappings(
        &self,
        params: GetRoleMappingsParams,
    ) -> Result<crate::security::RoleMappings, Error> {
        let GetRoleMappingsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the individual attributes of an action group.
    async fn patch_action_group(
        &self,
        params: PatchActionGroupParams,
    ) -> Result<crate::security::Ok, Error> {
        let PatchActionGroupParams {
            action_group,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups/{action_group}",
            local_var_configuration.base_path,
            action_group = action_group
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all node distinguished names. Requires super admin or REST API permissions.
    async fn get_distinguished_name(
        &self,
        params: GetDistinguishedNameParams,
    ) -> Result<GetDistinguishedNameSuccess, Error>
    {
        let GetDistinguishedNameParams {
            cluster_name,
            error_trace,
            filter_path,
            human,
            pretty,
            show_all,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn/{cluster_name}",
            local_var_configuration.base_path,
            cluster_name = cluster_name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = show_all {
            local_var_req_builder =
                local_var_req_builder.query(&[("show_all", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetDistinguishedNameSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieve all internal users.
    async fn get_users(
        &self,
        params: GetUsersParams,
    ) -> Result<crate::security::UsersMap, Error> {
        let GetUsersParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or updates multiple role mappings in a single request.
    async fn patch_role_mappings(
        &self,
        params: PatchRoleMappingsParams,
    ) -> Result<PatchRoleMappingsSuccess, Error> {
        let PatchRoleMappingsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchRoleMappingsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified user.
    async fn create_user(
        &self,
        params: CreateUserParams,
    ) -> Result<CreateUserSuccess, Error> {
        let CreateUserParams {
            create_user,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_user);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateUserSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Migrates the security configuration from v6 to v7.
    async fn migrate(
        &self,
        params: MigrateParams,
    ) -> Result<MigrateSuccess, Error> {
        let MigrateParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/migrate",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<MigrateSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Delete the specified user. Legacy API.
    async fn delete_user_legacy(
        &self,
        params: DeleteUserLegacyParams,
    ) -> Result<crate::security::Ok, Error> {
        let DeleteUserLegacyParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/user/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all action groups.
    async fn get_action_groups(
        &self,
        params: GetActionGroupsParams,
    ) -> Result<crate::security::ActionGroupsMap, Error> {
        let GetActionGroupsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates, updates, or deletes multiple internal users in a single request.
    async fn patch_users(
        &self,
        params: PatchUsersParams,
    ) -> Result<crate::security::Ok, Error> {
        let PatchUsersParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieve one user. Legacy API.
    async fn get_user_legacy(
        &self,
        params: GetUserLegacyParams,
    ) -> Result<crate::security::UsersMap, Error> {
        let GetUserLegacyParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/user/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes the specified role mapping.
    async fn delete_role_mapping(
        &self,
        params: DeleteRoleMappingParams,
    ) -> Result<crate::security::Ok, Error> {
        let DeleteRoleMappingParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/rolesmapping/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes the specified action group.
    async fn delete_action_group(
        &self,
        params: DeleteActionGroupParams,
    ) -> Result<crate::security::Ok, Error> {
        let DeleteActionGroupParams {
            action_group,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups/{action_group}",
            local_var_configuration.base_path,
            action_group = action_group
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates, updates, or deletes multiple roles in a single call.
    async fn patch_roles(
        &self,
        params: PatchRolesParams,
    ) -> Result<PatchRolesSuccess, Error> {
        let PatchRolesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchRolesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the audit configuration.
    async fn get_audit_configuration(
        &self,
        params: GetAuditConfigurationParams,
    ) -> Result<crate::security::AuditConfigWithReadOnly, Error>
    {
        let GetAuditConfigurationParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/audit",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes the specified tenant.
    async fn delete_tenant(
        &self,
        params: DeleteTenantParams,
    ) -> Result<DeleteTenantSuccess, Error> {
        let DeleteTenantParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            tenant,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants/{tenant}",
            local_var_configuration.base_path,
            tenant = tenant
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<DeleteTenantSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the names of current tenants. Requires super admin or `kibanaserver` permissions.
    async fn tenant_info(
        &self,
        params: TenantInfoParams,
    ) -> Result<TenantInfoSuccess, Error> {
        let TenantInfoParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/tenantinfo",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<TenantInfoSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes the specified role.
    async fn delete_role(
        &self,
        params: DeleteRoleParams,
    ) -> Result<crate::security::Ok, Error> {
        let DeleteRoleParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the cluster security certificates.
    async fn get_certificates(
        &self,
        params: GetCertificatesParams,
    ) -> Result<GetCertificatesSuccess, Error> {
        let GetCertificatesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/ssl/certs",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetCertificatesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified tenant.
    async fn create_tenant(
        &self,
        params: CreateTenantParams,
    ) -> Result<CreateTenantSuccess, Error> {
        let CreateTenantParams {
            create_tenant,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            tenant,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants/{tenant}",
            local_var_configuration.base_path,
            tenant = tenant
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_tenant);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateTenantSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Checks whether the v6 security configuration is valid and ready to be migrated to v7.
    async fn validate(
        &self,
        params: ValidateParams,
    ) -> Result<ValidateSuccess, Error> {
        let ValidateParams {
            accept_invalid,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/validate",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = accept_invalid {
            local_var_req_builder =
                local_var_req_builder.query(&[("accept_invalid", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<ValidateSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the evaluated REST API permissions for the currently logged in user.
    async fn get_permissions_info(
        &self,
        params: GetPermissionsInfoParams,
    ) -> Result<GetPermissionsInfoSuccess, Error> {
        let GetPermissionsInfoParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/permissionsinfo",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPermissionsInfoSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes all distinguished names in the specified cluster or node allowlist. Requires super admin or REST API permissions.
    async fn delete_distinguished_name(
        &self,
        params: DeleteDistinguishedNameParams,
    ) -> Result<DeleteDistinguishedNameSuccess, Error>
    {
        let DeleteDistinguishedNameParams {
            cluster_name,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn/{cluster_name}",
            local_var_configuration.base_path,
            cluster_name = cluster_name
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<DeleteDistinguishedNameSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Gets the identity information for the user currently logged in.
    async fn who_am_i(
        &self,
        params: WhoAmIParams,
    ) -> Result<WhoAmISuccess, Error> {
        let WhoAmIParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/whoami",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<WhoAmISuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Bulk updates specified node distinguished names. Requires super admin or REST API permissions.
    async fn patch_distinguished_names(
        &self,
        params: PatchDistinguishedNamesParams,
    ) -> Result<PatchDistinguishedNamesSuccess, Error>
    {
        let PatchDistinguishedNamesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchDistinguishedNamesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves the specified tenant.
    async fn get_tenant(
        &self,
        params: GetTenantParams,
    ) -> Result<crate::security::TenantsMap, Error> {
        let GetTenantParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            tenant,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants/{tenant}",
            local_var_configuration.base_path,
            tenant = tenant
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified role.
    async fn create_role(
        &self,
        params: CreateRoleParams,
    ) -> Result<CreateRoleSuccess, Error> {
        let CreateRoleParams {
            create_role,
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_role);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateRoleSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Deletes the specified internal user.
    async fn delete_user(
        &self,
        params: DeleteUserParams,
    ) -> Result<crate::security::Ok, Error> {
        let DeleteUserParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates, updates, or deletes multiple action groups in a single request.
    async fn patch_action_groups(
        &self,
        params: PatchActionGroupsParams,
    ) -> Result<crate::security::Ok, Error> {
        let PatchActionGroupsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieve information about the specified internal user.
    async fn get_user(
        &self,
        params: GetUserParams,
    ) -> Result<crate::security::UsersMap, Error> {
        let GetUserParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all roles.
    async fn get_roles(
        &self,
        params: GetRolesParams,
    ) -> Result<crate::security::RolesMap, Error> {
        let GetRolesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Flushes the Security plugin's user, authentication, and authorization cache.
    async fn flush_cache(
        &self,
        params: FlushCacheParams,
    ) -> Result<crate::security::Ok, Error> {
        let FlushCacheParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/cache",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified user. Legacy API.
    async fn create_user_legacy(
        &self,
        params: CreateUserLegacyParams,
    ) -> Result<CreateUserLegacySuccess, Error> {
        let CreateUserLegacyParams {
            create_user_legacy,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/user/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_user_legacy);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateUserLegacySuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Adds, deletes, or modifies multiple tenants in a single request.
    async fn patch_tenants(
        &self,
        params: PatchTenantsParams,
    ) -> Result<PatchTenantsSuccess, Error> {
        let PatchTenantsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchTenantsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the individual attributes of a role.
    async fn patch_role(
        &self,
        params: PatchRoleParams,
    ) -> Result<PatchRoleSuccess, Error> {
        let PatchRoleParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<PatchRoleSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves one role.
    async fn get_role(
        &self,
        params: GetRoleParams,
    ) -> Result<crate::security::RolesMap, Error> {
        let GetRoleParams {
            error_trace,
            filter_path,
            human,
            pretty,
            role,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/roles/{role}",
            local_var_configuration.base_path,
            role = role
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all node distinguished names. Requires super admin or REST API permissions.
    async fn get_distinguished_names(
        &self,
        params: GetDistinguishedNamesParams,
    ) -> Result<GetDistinguishedNamesSuccess, Error>
    {
        let GetDistinguishedNamesParams {
            error_trace,
            filter_path,
            human,
            pretty,
            show_all,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/nodesdn",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = show_all {
            local_var_req_builder =
                local_var_req_builder.query(&[("show_all", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetDistinguishedNamesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Not supported for the Cache API.
    async fn cache(
        &self,
        params: CacheParams,
    ) -> Result<crate::security::Error, Error> {
        let CacheParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/cache",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Creates or replaces the specified action group.
    async fn create_action_group(
        &self,
        params: CreateActionGroupParams,
    ) -> Result<CreateActionGroupSuccess, Error> {
        let CreateActionGroupParams {
            create_action_group,
            action_group,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/actiongroups/{action_group}",
            local_var_configuration.base_path,
            action_group = action_group
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&create_action_group);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<CreateActionGroupSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Returns the authorization token for the current user.
    async fn authtoken(
        &self,
        params: AuthtokenParams,
    ) -> Result<crate::security::Ok, Error> {
        let AuthtokenParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/authtoken",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates the audit configuration.
    async fn update_audit_configuration(
        &self,
        params: UpdateAuditConfigurationParams,
    ) -> Result<crate::security::Ok, Error> {
        let UpdateAuditConfigurationParams {
            update_audit_configuration,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/audit/config",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&update_audit_configuration);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Checks to see if the Security plugin is running.
    async fn health(
        &self,
        params: HealthParams,
    ) -> Result<crate::security::HealthInfo, Error> {
        let HealthParams {
            error_trace,
            filter_path,
            human,
            mode,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/health",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = mode {
            local_var_req_builder =
                local_var_req_builder.query(&[("mode", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieve all internal users. Legacy API.
    async fn get_users_legacy(
        &self,
        params: GetUsersLegacyParams,
    ) -> Result<crate::security::UsersMap, Error> {
        let GetUsersLegacyParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/user",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Updates individual attributes for an internal user.
    async fn patch_user(
        &self,
        params: PatchUserParams,
    ) -> Result<crate::security::Ok, Error> {
        let PatchUserParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
            username,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/internalusers/{username}",
            local_var_configuration.base_path,
            username = username
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Retrieves all tenants.
    async fn get_tenants(
        &self,
        params: GetTenantsParams,
    ) -> Result<GetTenantsSuccess, Error> {
        let GetTenantsParams {
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/tenants",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTenantsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
    ///
    /// Changes the password for the current user.
    async fn change_password(
        &self,
        params: ChangePasswordParams,
    ) -> Result<ChangePasswordSuccess, Error> {
        let ChangePasswordParams {
            change_password,
            error_trace,
            filter_path,
            human,
            pretty,
            source,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}_plugins/_security/api/account",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter_path {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter_path", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = error_trace {
            local_var_req_builder =
                local_var_req_builder.query(&[("error_trace", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = human {
            local_var_req_builder =
                local_var_req_builder.query(&[("human", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = pretty {
            local_var_req_builder =
                local_var_req_builder.query(&[("pretty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = source {
            local_var_req_builder =
                local_var_req_builder.query(&[("source", &local_var_str.to_string())]);
        }

        local_var_req_builder = local_var_req_builder.json(&change_password);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<ChangePasswordSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
            };
            Err(Error::ApiError(local_var_error))
        }
    }
}

/// Struct for typed errors of method [`get_dashboards_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDashboardsInfoError {
    DefaultResponse(crate::security::DashboardsInfo),
    Status500(crate::security::InternalServerError),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`patch_distinguished_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchDistinguishedNameError {
    Status400(crate::security::Error),
    Status403(crate::security::Error),
    DefaultResponse(crate::security::Ok),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`update_distinguished_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDistinguishedNameError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    Status403(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`authinfo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthinfoError {
    Status500(crate::security::InternalServerError),
    DefaultResponse(crate::security::AuthInfo),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`patch_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchTenantError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}





/// Struct for typed errors of method [`post_dashboards_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostDashboardsInfoError {
    Status500(crate::security::InternalServerError),
    DefaultResponse(crate::security::DashboardsInfo),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`patch_role_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleMappingError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}









/// Struct for typed errors of method [`get_distinguished_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistinguishedNameError {
    Status400(crate::security::Error),
    Status403(crate::security::Error),
    DefaultResponse(crate::security::DistinguishedNamesMap),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`patch_role_mappings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleMappingsError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`migrate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MigrateError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}













/// Struct for typed errors of method [`patch_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRolesError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`delete_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTenantError {
    Status400(crate::security::Error),
    DefaultResponse(crate::security::Ok),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`tenant_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantInfoError {
    DefaultResponse(crate::security::TenantInfo),
    Status403(String),
    Status500(crate::security::InternalServerError),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`get_certificates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificatesError {
    Status403(crate::security::Error),
    DefaultResponse(crate::security::GetCertificates),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`create_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTenantError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`get_permissions_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPermissionsInfoError {
    DefaultResponse(crate::security::PermissionsInfo),
    Status500(crate::security::InternalServerError),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`delete_distinguished_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDistinguishedNameError {
    Status403(crate::security::Error),
    Status400(crate::security::Error),
    DefaultResponse(crate::security::Ok),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`who_am_i`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WhoAmIError {
    DefaultResponse(crate::security::WhoAmI),
    Status500(crate::security::InternalServerError),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`patch_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchDistinguishedNamesError {
    Status403(crate::security::Error),
    Status400(crate::security::Error),
    DefaultResponse(crate::security::Ok),
    UnknownValue(serde_json::Value),
}

















/// Struct for typed errors of method [`patch_tenants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchTenantsError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`patch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleError {
    DefaultResponse(crate::security::Ok),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}



/// Struct for typed errors of method [`get_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistinguishedNamesError {
    DefaultResponse(crate::security::DistinguishedNamesMap),
    Status403(crate::security::Error),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`cache`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CacheError {
    Status501(crate::security::Error),
    UnknownValue(serde_json::Value),
}













/// Struct for typed errors of method [`get_tenants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTenantsError {
    DefaultResponse(crate::security::TenantsMap),
    Status400(crate::security::Error),
    UnknownValue(serde_json::Value),
}

/// Struct for typed errors of method [`change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangePasswordError {
    DefaultResponse(crate::security::Ok),
    Status403(crate::security::Error),
    UnknownValue(serde_json::Value),
}
